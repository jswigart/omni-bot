// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: recast.proto

#ifndef PROTOBUF_recast_2eproto__INCLUDED
#define PROTOBUF_recast_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace RecastIO {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_recast_2eproto();
void protobuf_AssignDesc_recast_2eproto();
void protobuf_ShutdownFile_recast_2eproto();

class Vec3;
class AxisAlignedBounds;
class NavMeshParams;
class Tile;
class OffMeshConnection;
class SubModel;
class NavigationMesh;

// ===================================================================

class Vec3 : public ::google::protobuf::Message {
 public:
  Vec3();
  virtual ~Vec3();

  Vec3(const Vec3& from);

  inline Vec3& operator=(const Vec3& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Vec3& default_instance();

  void Swap(Vec3* other);

  // implements Message ----------------------------------------------

  Vec3* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Vec3& from);
  void MergeFrom(const Vec3& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline float x() const;
  inline void set_x(float value);

  // optional float y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline float y() const;
  inline void set_y(float value);

  // optional float z = 3;
  inline bool has_z() const;
  inline void clear_z();
  static const int kZFieldNumber = 3;
  inline float z() const;
  inline void set_z(float value);

  // @@protoc_insertion_point(class_scope:RecastIO.Vec3)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_z();
  inline void clear_has_z();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  float x_;
  float y_;
  float z_;
  friend void  protobuf_AddDesc_recast_2eproto();
  friend void protobuf_AssignDesc_recast_2eproto();
  friend void protobuf_ShutdownFile_recast_2eproto();

  void InitAsDefaultInstance();
  static Vec3* default_instance_;
};
// -------------------------------------------------------------------

class AxisAlignedBounds : public ::google::protobuf::Message {
 public:
  AxisAlignedBounds();
  virtual ~AxisAlignedBounds();

  AxisAlignedBounds(const AxisAlignedBounds& from);

  inline AxisAlignedBounds& operator=(const AxisAlignedBounds& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AxisAlignedBounds& default_instance();

  void Swap(AxisAlignedBounds* other);

  // implements Message ----------------------------------------------

  AxisAlignedBounds* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AxisAlignedBounds& from);
  void MergeFrom(const AxisAlignedBounds& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .RecastIO.Vec3 mins = 1;
  inline bool has_mins() const;
  inline void clear_mins();
  static const int kMinsFieldNumber = 1;
  inline const ::RecastIO::Vec3& mins() const;
  inline ::RecastIO::Vec3* mutable_mins();
  inline ::RecastIO::Vec3* release_mins();
  inline void set_allocated_mins(::RecastIO::Vec3* mins);

  // required .RecastIO.Vec3 maxs = 2;
  inline bool has_maxs() const;
  inline void clear_maxs();
  static const int kMaxsFieldNumber = 2;
  inline const ::RecastIO::Vec3& maxs() const;
  inline ::RecastIO::Vec3* mutable_maxs();
  inline ::RecastIO::Vec3* release_maxs();
  inline void set_allocated_maxs(::RecastIO::Vec3* maxs);

  // @@protoc_insertion_point(class_scope:RecastIO.AxisAlignedBounds)
 private:
  inline void set_has_mins();
  inline void clear_has_mins();
  inline void set_has_maxs();
  inline void clear_has_maxs();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::RecastIO::Vec3* mins_;
  ::RecastIO::Vec3* maxs_;
  friend void  protobuf_AddDesc_recast_2eproto();
  friend void protobuf_AssignDesc_recast_2eproto();
  friend void protobuf_ShutdownFile_recast_2eproto();

  void InitAsDefaultInstance();
  static AxisAlignedBounds* default_instance_;
};
// -------------------------------------------------------------------

class NavMeshParams : public ::google::protobuf::Message {
 public:
  NavMeshParams();
  virtual ~NavMeshParams();

  NavMeshParams(const NavMeshParams& from);

  inline NavMeshParams& operator=(const NavMeshParams& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NavMeshParams& default_instance();

  void Swap(NavMeshParams* other);

  // implements Message ----------------------------------------------

  NavMeshParams* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NavMeshParams& from);
  void MergeFrom(const NavMeshParams& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float agentHeightStand = 1;
  inline bool has_agentheightstand() const;
  inline void clear_agentheightstand();
  static const int kAgentHeightStandFieldNumber = 1;
  inline float agentheightstand() const;
  inline void set_agentheightstand(float value);

  // required float agentHeightCrouch = 2;
  inline bool has_agentheightcrouch() const;
  inline void clear_agentheightcrouch();
  static const int kAgentHeightCrouchFieldNumber = 2;
  inline float agentheightcrouch() const;
  inline void set_agentheightcrouch(float value);

  // required float agentRadius = 3;
  inline bool has_agentradius() const;
  inline void clear_agentradius();
  static const int kAgentRadiusFieldNumber = 3;
  inline float agentradius() const;
  inline void set_agentradius(float value);

  // required float agentClimb = 4;
  inline bool has_agentclimb() const;
  inline void clear_agentclimb();
  static const int kAgentClimbFieldNumber = 4;
  inline float agentclimb() const;
  inline void set_agentclimb(float value);

  // required float walkSlopeAngle = 5;
  inline bool has_walkslopeangle() const;
  inline void clear_walkslopeangle();
  static const int kWalkSlopeAngleFieldNumber = 5;
  inline float walkslopeangle() const;
  inline void set_walkslopeangle(float value);

  // required float cellSize = 6;
  inline bool has_cellsize() const;
  inline void clear_cellsize();
  static const int kCellSizeFieldNumber = 6;
  inline float cellsize() const;
  inline void set_cellsize(float value);

  // required float cellHeight = 7;
  inline bool has_cellheight() const;
  inline void clear_cellheight();
  static const int kCellHeightFieldNumber = 7;
  inline float cellheight() const;
  inline void set_cellheight(float value);

  // required float edgeMaxLength = 8;
  inline bool has_edgemaxlength() const;
  inline void clear_edgemaxlength();
  static const int kEdgeMaxLengthFieldNumber = 8;
  inline float edgemaxlength() const;
  inline void set_edgemaxlength(float value);

  // required float edgeMaxError = 9;
  inline bool has_edgemaxerror() const;
  inline void clear_edgemaxerror();
  static const int kEdgeMaxErrorFieldNumber = 9;
  inline float edgemaxerror() const;
  inline void set_edgemaxerror(float value);

  // required int32 tileSize = 10;
  inline bool has_tilesize() const;
  inline void clear_tilesize();
  static const int kTileSizeFieldNumber = 10;
  inline ::google::protobuf::int32 tilesize() const;
  inline void set_tilesize(::google::protobuf::int32 value);

  // required float detailSampleDist = 11;
  inline bool has_detailsampledist() const;
  inline void clear_detailsampledist();
  static const int kDetailSampleDistFieldNumber = 11;
  inline float detailsampledist() const;
  inline void set_detailsampledist(float value);

  // required float detailSampleMaxErr = 12;
  inline bool has_detailsamplemaxerr() const;
  inline void clear_detailsamplemaxerr();
  static const int kDetailSampleMaxErrFieldNumber = 12;
  inline float detailsamplemaxerr() const;
  inline void set_detailsamplemaxerr(float value);

  // @@protoc_insertion_point(class_scope:RecastIO.NavMeshParams)
 private:
  inline void set_has_agentheightstand();
  inline void clear_has_agentheightstand();
  inline void set_has_agentheightcrouch();
  inline void clear_has_agentheightcrouch();
  inline void set_has_agentradius();
  inline void clear_has_agentradius();
  inline void set_has_agentclimb();
  inline void clear_has_agentclimb();
  inline void set_has_walkslopeangle();
  inline void clear_has_walkslopeangle();
  inline void set_has_cellsize();
  inline void clear_has_cellsize();
  inline void set_has_cellheight();
  inline void clear_has_cellheight();
  inline void set_has_edgemaxlength();
  inline void clear_has_edgemaxlength();
  inline void set_has_edgemaxerror();
  inline void clear_has_edgemaxerror();
  inline void set_has_tilesize();
  inline void clear_has_tilesize();
  inline void set_has_detailsampledist();
  inline void clear_has_detailsampledist();
  inline void set_has_detailsamplemaxerr();
  inline void clear_has_detailsamplemaxerr();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  float agentheightstand_;
  float agentheightcrouch_;
  float agentradius_;
  float agentclimb_;
  float walkslopeangle_;
  float cellsize_;
  float cellheight_;
  float edgemaxlength_;
  float edgemaxerror_;
  ::google::protobuf::int32 tilesize_;
  float detailsampledist_;
  float detailsamplemaxerr_;
  friend void  protobuf_AddDesc_recast_2eproto();
  friend void protobuf_AssignDesc_recast_2eproto();
  friend void protobuf_ShutdownFile_recast_2eproto();

  void InitAsDefaultInstance();
  static NavMeshParams* default_instance_;
};
// -------------------------------------------------------------------

class Tile : public ::google::protobuf::Message {
 public:
  Tile();
  virtual ~Tile();

  Tile(const Tile& from);

  inline Tile& operator=(const Tile& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Tile& default_instance();

  void Swap(Tile* other);

  // implements Message ----------------------------------------------

  Tile* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Tile& from);
  void MergeFrom(const Tile& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 unCompressedSize = 1;
  inline bool has_uncompressedsize() const;
  inline void clear_uncompressedsize();
  static const int kUnCompressedSizeFieldNumber = 1;
  inline ::google::protobuf::int32 uncompressedsize() const;
  inline void set_uncompressedsize(::google::protobuf::int32 value);

  // required bytes compressedData = 2;
  inline bool has_compresseddata() const;
  inline void clear_compresseddata();
  static const int kCompressedDataFieldNumber = 2;
  inline const ::std::string& compresseddata() const;
  inline void set_compresseddata(const ::std::string& value);
  inline void set_compresseddata(const char* value);
  inline void set_compresseddata(const void* value, size_t size);
  inline ::std::string* mutable_compresseddata();
  inline ::std::string* release_compresseddata();
  inline void set_allocated_compresseddata(::std::string* compresseddata);

  // @@protoc_insertion_point(class_scope:RecastIO.Tile)
 private:
  inline void set_has_uncompressedsize();
  inline void clear_has_uncompressedsize();
  inline void set_has_compresseddata();
  inline void clear_has_compresseddata();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* compresseddata_;
  ::google::protobuf::int32 uncompressedsize_;
  friend void  protobuf_AddDesc_recast_2eproto();
  friend void protobuf_AssignDesc_recast_2eproto();
  friend void protobuf_ShutdownFile_recast_2eproto();

  void InitAsDefaultInstance();
  static Tile* default_instance_;
};
// -------------------------------------------------------------------

class OffMeshConnection : public ::google::protobuf::Message {
 public:
  OffMeshConnection();
  virtual ~OffMeshConnection();

  OffMeshConnection(const OffMeshConnection& from);

  inline OffMeshConnection& operator=(const OffMeshConnection& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OffMeshConnection& default_instance();

  void Swap(OffMeshConnection* other);

  // implements Message ----------------------------------------------

  OffMeshConnection* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OffMeshConnection& from);
  void MergeFrom(const OffMeshConnection& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .RecastIO.Vec3 entryPos = 1;
  inline bool has_entrypos() const;
  inline void clear_entrypos();
  static const int kEntryPosFieldNumber = 1;
  inline const ::RecastIO::Vec3& entrypos() const;
  inline ::RecastIO::Vec3* mutable_entrypos();
  inline ::RecastIO::Vec3* release_entrypos();
  inline void set_allocated_entrypos(::RecastIO::Vec3* entrypos);

  // required .RecastIO.Vec3 exitPos = 2;
  inline bool has_exitpos() const;
  inline void clear_exitpos();
  static const int kExitPosFieldNumber = 2;
  inline const ::RecastIO::Vec3& exitpos() const;
  inline ::RecastIO::Vec3* mutable_exitpos();
  inline ::RecastIO::Vec3* release_exitpos();
  inline void set_allocated_exitpos(::RecastIO::Vec3* exitpos);

  // repeated .RecastIO.Vec3 intermediatePos = 3;
  inline int intermediatepos_size() const;
  inline void clear_intermediatepos();
  static const int kIntermediatePosFieldNumber = 3;
  inline const ::RecastIO::Vec3& intermediatepos(int index) const;
  inline ::RecastIO::Vec3* mutable_intermediatepos(int index);
  inline ::RecastIO::Vec3* add_intermediatepos();
  inline const ::google::protobuf::RepeatedPtrField< ::RecastIO::Vec3 >&
      intermediatepos() const;
  inline ::google::protobuf::RepeatedPtrField< ::RecastIO::Vec3 >*
      mutable_intermediatepos();

  // required float radius = 4;
  inline bool has_radius() const;
  inline void clear_radius();
  static const int kRadiusFieldNumber = 4;
  inline float radius() const;
  inline void set_radius(float value);

  // required uint32 areaType = 5;
  inline bool has_areatype() const;
  inline void clear_areatype();
  static const int kAreaTypeFieldNumber = 5;
  inline ::google::protobuf::uint32 areatype() const;
  inline void set_areatype(::google::protobuf::uint32 value);

  // required uint32 flags = 6;
  inline bool has_flags() const;
  inline void clear_flags();
  static const int kFlagsFieldNumber = 6;
  inline ::google::protobuf::uint32 flags() const;
  inline void set_flags(::google::protobuf::uint32 value);

  // optional bool biDirectional = 7 [default = false];
  inline bool has_bidirectional() const;
  inline void clear_bidirectional();
  static const int kBiDirectionalFieldNumber = 7;
  inline bool bidirectional() const;
  inline void set_bidirectional(bool value);

  // @@protoc_insertion_point(class_scope:RecastIO.OffMeshConnection)
 private:
  inline void set_has_entrypos();
  inline void clear_has_entrypos();
  inline void set_has_exitpos();
  inline void clear_has_exitpos();
  inline void set_has_radius();
  inline void clear_has_radius();
  inline void set_has_areatype();
  inline void clear_has_areatype();
  inline void set_has_flags();
  inline void clear_has_flags();
  inline void set_has_bidirectional();
  inline void clear_has_bidirectional();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::RecastIO::Vec3* entrypos_;
  ::RecastIO::Vec3* exitpos_;
  ::google::protobuf::RepeatedPtrField< ::RecastIO::Vec3 > intermediatepos_;
  float radius_;
  ::google::protobuf::uint32 areatype_;
  ::google::protobuf::uint32 flags_;
  bool bidirectional_;
  friend void  protobuf_AddDesc_recast_2eproto();
  friend void protobuf_AssignDesc_recast_2eproto();
  friend void protobuf_ShutdownFile_recast_2eproto();

  void InitAsDefaultInstance();
  static OffMeshConnection* default_instance_;
};
// -------------------------------------------------------------------

class SubModel : public ::google::protobuf::Message {
 public:
  SubModel();
  virtual ~SubModel();

  SubModel(const SubModel& from);

  inline SubModel& operator=(const SubModel& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SubModel& default_instance();

  void Swap(SubModel* other);

  // implements Message ----------------------------------------------

  SubModel* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SubModel& from);
  void MergeFrom(const SubModel& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 submodelId = 1;
  inline bool has_submodelid() const;
  inline void clear_submodelid();
  static const int kSubmodelIdFieldNumber = 1;
  inline ::google::protobuf::int32 submodelid() const;
  inline void set_submodelid(::google::protobuf::int32 value);

  // optional bool disabled = 2;
  inline bool has_disabled() const;
  inline void clear_disabled();
  static const int kDisabledFieldNumber = 2;
  inline bool disabled() const;
  inline void set_disabled(bool value);

  // optional bool mover = 3;
  inline bool has_mover() const;
  inline void clear_mover();
  static const int kMoverFieldNumber = 3;
  inline bool mover() const;
  inline void set_mover(bool value);

  // optional bool nonsolid = 4;
  inline bool has_nonsolid() const;
  inline void clear_nonsolid();
  static const int kNonsolidFieldNumber = 4;
  inline bool nonsolid() const;
  inline void set_nonsolid(bool value);

  // @@protoc_insertion_point(class_scope:RecastIO.SubModel)
 private:
  inline void set_has_submodelid();
  inline void clear_has_submodelid();
  inline void set_has_disabled();
  inline void clear_has_disabled();
  inline void set_has_mover();
  inline void clear_has_mover();
  inline void set_has_nonsolid();
  inline void clear_has_nonsolid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 submodelid_;
  bool disabled_;
  bool mover_;
  bool nonsolid_;
  friend void  protobuf_AddDesc_recast_2eproto();
  friend void protobuf_AssignDesc_recast_2eproto();
  friend void protobuf_ShutdownFile_recast_2eproto();

  void InitAsDefaultInstance();
  static SubModel* default_instance_;
};
// -------------------------------------------------------------------

class NavigationMesh : public ::google::protobuf::Message {
 public:
  NavigationMesh();
  virtual ~NavigationMesh();

  NavigationMesh(const NavigationMesh& from);

  inline NavigationMesh& operator=(const NavigationMesh& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NavigationMesh& default_instance();

  void Swap(NavigationMesh* other);

  // implements Message ----------------------------------------------

  NavigationMesh* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NavigationMesh& from);
  void MergeFrom(const NavigationMesh& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 version = 1;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 1;
  inline ::google::protobuf::int32 version() const;
  inline void set_version(::google::protobuf::int32 value);

  // required .RecastIO.NavMeshParams navMeshParams = 2;
  inline bool has_navmeshparams() const;
  inline void clear_navmeshparams();
  static const int kNavMeshParamsFieldNumber = 2;
  inline const ::RecastIO::NavMeshParams& navmeshparams() const;
  inline ::RecastIO::NavMeshParams* mutable_navmeshparams();
  inline ::RecastIO::NavMeshParams* release_navmeshparams();
  inline void set_allocated_navmeshparams(::RecastIO::NavMeshParams* navmeshparams);

  // repeated .RecastIO.Tile tiles = 3;
  inline int tiles_size() const;
  inline void clear_tiles();
  static const int kTilesFieldNumber = 3;
  inline const ::RecastIO::Tile& tiles(int index) const;
  inline ::RecastIO::Tile* mutable_tiles(int index);
  inline ::RecastIO::Tile* add_tiles();
  inline const ::google::protobuf::RepeatedPtrField< ::RecastIO::Tile >&
      tiles() const;
  inline ::google::protobuf::RepeatedPtrField< ::RecastIO::Tile >*
      mutable_tiles();

  // repeated .RecastIO.AxisAlignedBounds exclusionZone = 4;
  inline int exclusionzone_size() const;
  inline void clear_exclusionzone();
  static const int kExclusionZoneFieldNumber = 4;
  inline const ::RecastIO::AxisAlignedBounds& exclusionzone(int index) const;
  inline ::RecastIO::AxisAlignedBounds* mutable_exclusionzone(int index);
  inline ::RecastIO::AxisAlignedBounds* add_exclusionzone();
  inline const ::google::protobuf::RepeatedPtrField< ::RecastIO::AxisAlignedBounds >&
      exclusionzone() const;
  inline ::google::protobuf::RepeatedPtrField< ::RecastIO::AxisAlignedBounds >*
      mutable_exclusionzone();

  // repeated .RecastIO.OffMeshConnection offMeshConnection = 5;
  inline int offmeshconnection_size() const;
  inline void clear_offmeshconnection();
  static const int kOffMeshConnectionFieldNumber = 5;
  inline const ::RecastIO::OffMeshConnection& offmeshconnection(int index) const;
  inline ::RecastIO::OffMeshConnection* mutable_offmeshconnection(int index);
  inline ::RecastIO::OffMeshConnection* add_offmeshconnection();
  inline const ::google::protobuf::RepeatedPtrField< ::RecastIO::OffMeshConnection >&
      offmeshconnection() const;
  inline ::google::protobuf::RepeatedPtrField< ::RecastIO::OffMeshConnection >*
      mutable_offmeshconnection();

  // repeated .RecastIO.SubModel subModelInfo = 6;
  inline int submodelinfo_size() const;
  inline void clear_submodelinfo();
  static const int kSubModelInfoFieldNumber = 6;
  inline const ::RecastIO::SubModel& submodelinfo(int index) const;
  inline ::RecastIO::SubModel* mutable_submodelinfo(int index);
  inline ::RecastIO::SubModel* add_submodelinfo();
  inline const ::google::protobuf::RepeatedPtrField< ::RecastIO::SubModel >&
      submodelinfo() const;
  inline ::google::protobuf::RepeatedPtrField< ::RecastIO::SubModel >*
      mutable_submodelinfo();

  // @@protoc_insertion_point(class_scope:RecastIO.NavigationMesh)
 private:
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_navmeshparams();
  inline void clear_has_navmeshparams();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::RecastIO::NavMeshParams* navmeshparams_;
  ::google::protobuf::RepeatedPtrField< ::RecastIO::Tile > tiles_;
  ::google::protobuf::RepeatedPtrField< ::RecastIO::AxisAlignedBounds > exclusionzone_;
  ::google::protobuf::RepeatedPtrField< ::RecastIO::OffMeshConnection > offmeshconnection_;
  ::google::protobuf::RepeatedPtrField< ::RecastIO::SubModel > submodelinfo_;
  ::google::protobuf::int32 version_;
  friend void  protobuf_AddDesc_recast_2eproto();
  friend void protobuf_AssignDesc_recast_2eproto();
  friend void protobuf_ShutdownFile_recast_2eproto();

  void InitAsDefaultInstance();
  static NavigationMesh* default_instance_;
};
// ===================================================================


// ===================================================================

// Vec3

// optional float x = 1;
inline bool Vec3::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Vec3::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Vec3::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Vec3::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float Vec3::x() const {
  // @@protoc_insertion_point(field_get:RecastIO.Vec3.x)
  return x_;
}
inline void Vec3::set_x(float value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:RecastIO.Vec3.x)
}

// optional float y = 2;
inline bool Vec3::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Vec3::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Vec3::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Vec3::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float Vec3::y() const {
  // @@protoc_insertion_point(field_get:RecastIO.Vec3.y)
  return y_;
}
inline void Vec3::set_y(float value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:RecastIO.Vec3.y)
}

// optional float z = 3;
inline bool Vec3::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Vec3::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Vec3::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Vec3::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline float Vec3::z() const {
  // @@protoc_insertion_point(field_get:RecastIO.Vec3.z)
  return z_;
}
inline void Vec3::set_z(float value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:RecastIO.Vec3.z)
}

// -------------------------------------------------------------------

// AxisAlignedBounds

// required .RecastIO.Vec3 mins = 1;
inline bool AxisAlignedBounds::has_mins() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AxisAlignedBounds::set_has_mins() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AxisAlignedBounds::clear_has_mins() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AxisAlignedBounds::clear_mins() {
  if (mins_ != NULL) mins_->::RecastIO::Vec3::Clear();
  clear_has_mins();
}
inline const ::RecastIO::Vec3& AxisAlignedBounds::mins() const {
  // @@protoc_insertion_point(field_get:RecastIO.AxisAlignedBounds.mins)
  return mins_ != NULL ? *mins_ : *default_instance_->mins_;
}
inline ::RecastIO::Vec3* AxisAlignedBounds::mutable_mins() {
  set_has_mins();
  if (mins_ == NULL) mins_ = new ::RecastIO::Vec3;
  // @@protoc_insertion_point(field_mutable:RecastIO.AxisAlignedBounds.mins)
  return mins_;
}
inline ::RecastIO::Vec3* AxisAlignedBounds::release_mins() {
  clear_has_mins();
  ::RecastIO::Vec3* temp = mins_;
  mins_ = NULL;
  return temp;
}
inline void AxisAlignedBounds::set_allocated_mins(::RecastIO::Vec3* mins) {
  delete mins_;
  mins_ = mins;
  if (mins) {
    set_has_mins();
  } else {
    clear_has_mins();
  }
  // @@protoc_insertion_point(field_set_allocated:RecastIO.AxisAlignedBounds.mins)
}

// required .RecastIO.Vec3 maxs = 2;
inline bool AxisAlignedBounds::has_maxs() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AxisAlignedBounds::set_has_maxs() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AxisAlignedBounds::clear_has_maxs() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AxisAlignedBounds::clear_maxs() {
  if (maxs_ != NULL) maxs_->::RecastIO::Vec3::Clear();
  clear_has_maxs();
}
inline const ::RecastIO::Vec3& AxisAlignedBounds::maxs() const {
  // @@protoc_insertion_point(field_get:RecastIO.AxisAlignedBounds.maxs)
  return maxs_ != NULL ? *maxs_ : *default_instance_->maxs_;
}
inline ::RecastIO::Vec3* AxisAlignedBounds::mutable_maxs() {
  set_has_maxs();
  if (maxs_ == NULL) maxs_ = new ::RecastIO::Vec3;
  // @@protoc_insertion_point(field_mutable:RecastIO.AxisAlignedBounds.maxs)
  return maxs_;
}
inline ::RecastIO::Vec3* AxisAlignedBounds::release_maxs() {
  clear_has_maxs();
  ::RecastIO::Vec3* temp = maxs_;
  maxs_ = NULL;
  return temp;
}
inline void AxisAlignedBounds::set_allocated_maxs(::RecastIO::Vec3* maxs) {
  delete maxs_;
  maxs_ = maxs;
  if (maxs) {
    set_has_maxs();
  } else {
    clear_has_maxs();
  }
  // @@protoc_insertion_point(field_set_allocated:RecastIO.AxisAlignedBounds.maxs)
}

// -------------------------------------------------------------------

// NavMeshParams

// required float agentHeightStand = 1;
inline bool NavMeshParams::has_agentheightstand() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NavMeshParams::set_has_agentheightstand() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NavMeshParams::clear_has_agentheightstand() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NavMeshParams::clear_agentheightstand() {
  agentheightstand_ = 0;
  clear_has_agentheightstand();
}
inline float NavMeshParams::agentheightstand() const {
  // @@protoc_insertion_point(field_get:RecastIO.NavMeshParams.agentHeightStand)
  return agentheightstand_;
}
inline void NavMeshParams::set_agentheightstand(float value) {
  set_has_agentheightstand();
  agentheightstand_ = value;
  // @@protoc_insertion_point(field_set:RecastIO.NavMeshParams.agentHeightStand)
}

// required float agentHeightCrouch = 2;
inline bool NavMeshParams::has_agentheightcrouch() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NavMeshParams::set_has_agentheightcrouch() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NavMeshParams::clear_has_agentheightcrouch() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NavMeshParams::clear_agentheightcrouch() {
  agentheightcrouch_ = 0;
  clear_has_agentheightcrouch();
}
inline float NavMeshParams::agentheightcrouch() const {
  // @@protoc_insertion_point(field_get:RecastIO.NavMeshParams.agentHeightCrouch)
  return agentheightcrouch_;
}
inline void NavMeshParams::set_agentheightcrouch(float value) {
  set_has_agentheightcrouch();
  agentheightcrouch_ = value;
  // @@protoc_insertion_point(field_set:RecastIO.NavMeshParams.agentHeightCrouch)
}

// required float agentRadius = 3;
inline bool NavMeshParams::has_agentradius() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NavMeshParams::set_has_agentradius() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NavMeshParams::clear_has_agentradius() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NavMeshParams::clear_agentradius() {
  agentradius_ = 0;
  clear_has_agentradius();
}
inline float NavMeshParams::agentradius() const {
  // @@protoc_insertion_point(field_get:RecastIO.NavMeshParams.agentRadius)
  return agentradius_;
}
inline void NavMeshParams::set_agentradius(float value) {
  set_has_agentradius();
  agentradius_ = value;
  // @@protoc_insertion_point(field_set:RecastIO.NavMeshParams.agentRadius)
}

// required float agentClimb = 4;
inline bool NavMeshParams::has_agentclimb() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void NavMeshParams::set_has_agentclimb() {
  _has_bits_[0] |= 0x00000008u;
}
inline void NavMeshParams::clear_has_agentclimb() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void NavMeshParams::clear_agentclimb() {
  agentclimb_ = 0;
  clear_has_agentclimb();
}
inline float NavMeshParams::agentclimb() const {
  // @@protoc_insertion_point(field_get:RecastIO.NavMeshParams.agentClimb)
  return agentclimb_;
}
inline void NavMeshParams::set_agentclimb(float value) {
  set_has_agentclimb();
  agentclimb_ = value;
  // @@protoc_insertion_point(field_set:RecastIO.NavMeshParams.agentClimb)
}

// required float walkSlopeAngle = 5;
inline bool NavMeshParams::has_walkslopeangle() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void NavMeshParams::set_has_walkslopeangle() {
  _has_bits_[0] |= 0x00000010u;
}
inline void NavMeshParams::clear_has_walkslopeangle() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void NavMeshParams::clear_walkslopeangle() {
  walkslopeangle_ = 0;
  clear_has_walkslopeangle();
}
inline float NavMeshParams::walkslopeangle() const {
  // @@protoc_insertion_point(field_get:RecastIO.NavMeshParams.walkSlopeAngle)
  return walkslopeangle_;
}
inline void NavMeshParams::set_walkslopeangle(float value) {
  set_has_walkslopeangle();
  walkslopeangle_ = value;
  // @@protoc_insertion_point(field_set:RecastIO.NavMeshParams.walkSlopeAngle)
}

// required float cellSize = 6;
inline bool NavMeshParams::has_cellsize() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void NavMeshParams::set_has_cellsize() {
  _has_bits_[0] |= 0x00000020u;
}
inline void NavMeshParams::clear_has_cellsize() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void NavMeshParams::clear_cellsize() {
  cellsize_ = 0;
  clear_has_cellsize();
}
inline float NavMeshParams::cellsize() const {
  // @@protoc_insertion_point(field_get:RecastIO.NavMeshParams.cellSize)
  return cellsize_;
}
inline void NavMeshParams::set_cellsize(float value) {
  set_has_cellsize();
  cellsize_ = value;
  // @@protoc_insertion_point(field_set:RecastIO.NavMeshParams.cellSize)
}

// required float cellHeight = 7;
inline bool NavMeshParams::has_cellheight() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void NavMeshParams::set_has_cellheight() {
  _has_bits_[0] |= 0x00000040u;
}
inline void NavMeshParams::clear_has_cellheight() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void NavMeshParams::clear_cellheight() {
  cellheight_ = 0;
  clear_has_cellheight();
}
inline float NavMeshParams::cellheight() const {
  // @@protoc_insertion_point(field_get:RecastIO.NavMeshParams.cellHeight)
  return cellheight_;
}
inline void NavMeshParams::set_cellheight(float value) {
  set_has_cellheight();
  cellheight_ = value;
  // @@protoc_insertion_point(field_set:RecastIO.NavMeshParams.cellHeight)
}

// required float edgeMaxLength = 8;
inline bool NavMeshParams::has_edgemaxlength() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void NavMeshParams::set_has_edgemaxlength() {
  _has_bits_[0] |= 0x00000080u;
}
inline void NavMeshParams::clear_has_edgemaxlength() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void NavMeshParams::clear_edgemaxlength() {
  edgemaxlength_ = 0;
  clear_has_edgemaxlength();
}
inline float NavMeshParams::edgemaxlength() const {
  // @@protoc_insertion_point(field_get:RecastIO.NavMeshParams.edgeMaxLength)
  return edgemaxlength_;
}
inline void NavMeshParams::set_edgemaxlength(float value) {
  set_has_edgemaxlength();
  edgemaxlength_ = value;
  // @@protoc_insertion_point(field_set:RecastIO.NavMeshParams.edgeMaxLength)
}

// required float edgeMaxError = 9;
inline bool NavMeshParams::has_edgemaxerror() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void NavMeshParams::set_has_edgemaxerror() {
  _has_bits_[0] |= 0x00000100u;
}
inline void NavMeshParams::clear_has_edgemaxerror() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void NavMeshParams::clear_edgemaxerror() {
  edgemaxerror_ = 0;
  clear_has_edgemaxerror();
}
inline float NavMeshParams::edgemaxerror() const {
  // @@protoc_insertion_point(field_get:RecastIO.NavMeshParams.edgeMaxError)
  return edgemaxerror_;
}
inline void NavMeshParams::set_edgemaxerror(float value) {
  set_has_edgemaxerror();
  edgemaxerror_ = value;
  // @@protoc_insertion_point(field_set:RecastIO.NavMeshParams.edgeMaxError)
}

// required int32 tileSize = 10;
inline bool NavMeshParams::has_tilesize() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void NavMeshParams::set_has_tilesize() {
  _has_bits_[0] |= 0x00000200u;
}
inline void NavMeshParams::clear_has_tilesize() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void NavMeshParams::clear_tilesize() {
  tilesize_ = 0;
  clear_has_tilesize();
}
inline ::google::protobuf::int32 NavMeshParams::tilesize() const {
  // @@protoc_insertion_point(field_get:RecastIO.NavMeshParams.tileSize)
  return tilesize_;
}
inline void NavMeshParams::set_tilesize(::google::protobuf::int32 value) {
  set_has_tilesize();
  tilesize_ = value;
  // @@protoc_insertion_point(field_set:RecastIO.NavMeshParams.tileSize)
}

// required float detailSampleDist = 11;
inline bool NavMeshParams::has_detailsampledist() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void NavMeshParams::set_has_detailsampledist() {
  _has_bits_[0] |= 0x00000400u;
}
inline void NavMeshParams::clear_has_detailsampledist() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void NavMeshParams::clear_detailsampledist() {
  detailsampledist_ = 0;
  clear_has_detailsampledist();
}
inline float NavMeshParams::detailsampledist() const {
  // @@protoc_insertion_point(field_get:RecastIO.NavMeshParams.detailSampleDist)
  return detailsampledist_;
}
inline void NavMeshParams::set_detailsampledist(float value) {
  set_has_detailsampledist();
  detailsampledist_ = value;
  // @@protoc_insertion_point(field_set:RecastIO.NavMeshParams.detailSampleDist)
}

// required float detailSampleMaxErr = 12;
inline bool NavMeshParams::has_detailsamplemaxerr() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void NavMeshParams::set_has_detailsamplemaxerr() {
  _has_bits_[0] |= 0x00000800u;
}
inline void NavMeshParams::clear_has_detailsamplemaxerr() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void NavMeshParams::clear_detailsamplemaxerr() {
  detailsamplemaxerr_ = 0;
  clear_has_detailsamplemaxerr();
}
inline float NavMeshParams::detailsamplemaxerr() const {
  // @@protoc_insertion_point(field_get:RecastIO.NavMeshParams.detailSampleMaxErr)
  return detailsamplemaxerr_;
}
inline void NavMeshParams::set_detailsamplemaxerr(float value) {
  set_has_detailsamplemaxerr();
  detailsamplemaxerr_ = value;
  // @@protoc_insertion_point(field_set:RecastIO.NavMeshParams.detailSampleMaxErr)
}

// -------------------------------------------------------------------

// Tile

// required int32 unCompressedSize = 1;
inline bool Tile::has_uncompressedsize() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Tile::set_has_uncompressedsize() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Tile::clear_has_uncompressedsize() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Tile::clear_uncompressedsize() {
  uncompressedsize_ = 0;
  clear_has_uncompressedsize();
}
inline ::google::protobuf::int32 Tile::uncompressedsize() const {
  // @@protoc_insertion_point(field_get:RecastIO.Tile.unCompressedSize)
  return uncompressedsize_;
}
inline void Tile::set_uncompressedsize(::google::protobuf::int32 value) {
  set_has_uncompressedsize();
  uncompressedsize_ = value;
  // @@protoc_insertion_point(field_set:RecastIO.Tile.unCompressedSize)
}

// required bytes compressedData = 2;
inline bool Tile::has_compresseddata() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Tile::set_has_compresseddata() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Tile::clear_has_compresseddata() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Tile::clear_compresseddata() {
  if (compresseddata_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    compresseddata_->clear();
  }
  clear_has_compresseddata();
}
inline const ::std::string& Tile::compresseddata() const {
  // @@protoc_insertion_point(field_get:RecastIO.Tile.compressedData)
  return *compresseddata_;
}
inline void Tile::set_compresseddata(const ::std::string& value) {
  set_has_compresseddata();
  if (compresseddata_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    compresseddata_ = new ::std::string;
  }
  compresseddata_->assign(value);
  // @@protoc_insertion_point(field_set:RecastIO.Tile.compressedData)
}
inline void Tile::set_compresseddata(const char* value) {
  set_has_compresseddata();
  if (compresseddata_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    compresseddata_ = new ::std::string;
  }
  compresseddata_->assign(value);
  // @@protoc_insertion_point(field_set_char:RecastIO.Tile.compressedData)
}
inline void Tile::set_compresseddata(const void* value, size_t size) {
  set_has_compresseddata();
  if (compresseddata_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    compresseddata_ = new ::std::string;
  }
  compresseddata_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:RecastIO.Tile.compressedData)
}
inline ::std::string* Tile::mutable_compresseddata() {
  set_has_compresseddata();
  if (compresseddata_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    compresseddata_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:RecastIO.Tile.compressedData)
  return compresseddata_;
}
inline ::std::string* Tile::release_compresseddata() {
  clear_has_compresseddata();
  if (compresseddata_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = compresseddata_;
    compresseddata_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Tile::set_allocated_compresseddata(::std::string* compresseddata) {
  if (compresseddata_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete compresseddata_;
  }
  if (compresseddata) {
    set_has_compresseddata();
    compresseddata_ = compresseddata;
  } else {
    clear_has_compresseddata();
    compresseddata_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:RecastIO.Tile.compressedData)
}

// -------------------------------------------------------------------

// OffMeshConnection

// required .RecastIO.Vec3 entryPos = 1;
inline bool OffMeshConnection::has_entrypos() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OffMeshConnection::set_has_entrypos() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OffMeshConnection::clear_has_entrypos() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OffMeshConnection::clear_entrypos() {
  if (entrypos_ != NULL) entrypos_->::RecastIO::Vec3::Clear();
  clear_has_entrypos();
}
inline const ::RecastIO::Vec3& OffMeshConnection::entrypos() const {
  // @@protoc_insertion_point(field_get:RecastIO.OffMeshConnection.entryPos)
  return entrypos_ != NULL ? *entrypos_ : *default_instance_->entrypos_;
}
inline ::RecastIO::Vec3* OffMeshConnection::mutable_entrypos() {
  set_has_entrypos();
  if (entrypos_ == NULL) entrypos_ = new ::RecastIO::Vec3;
  // @@protoc_insertion_point(field_mutable:RecastIO.OffMeshConnection.entryPos)
  return entrypos_;
}
inline ::RecastIO::Vec3* OffMeshConnection::release_entrypos() {
  clear_has_entrypos();
  ::RecastIO::Vec3* temp = entrypos_;
  entrypos_ = NULL;
  return temp;
}
inline void OffMeshConnection::set_allocated_entrypos(::RecastIO::Vec3* entrypos) {
  delete entrypos_;
  entrypos_ = entrypos;
  if (entrypos) {
    set_has_entrypos();
  } else {
    clear_has_entrypos();
  }
  // @@protoc_insertion_point(field_set_allocated:RecastIO.OffMeshConnection.entryPos)
}

// required .RecastIO.Vec3 exitPos = 2;
inline bool OffMeshConnection::has_exitpos() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OffMeshConnection::set_has_exitpos() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OffMeshConnection::clear_has_exitpos() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OffMeshConnection::clear_exitpos() {
  if (exitpos_ != NULL) exitpos_->::RecastIO::Vec3::Clear();
  clear_has_exitpos();
}
inline const ::RecastIO::Vec3& OffMeshConnection::exitpos() const {
  // @@protoc_insertion_point(field_get:RecastIO.OffMeshConnection.exitPos)
  return exitpos_ != NULL ? *exitpos_ : *default_instance_->exitpos_;
}
inline ::RecastIO::Vec3* OffMeshConnection::mutable_exitpos() {
  set_has_exitpos();
  if (exitpos_ == NULL) exitpos_ = new ::RecastIO::Vec3;
  // @@protoc_insertion_point(field_mutable:RecastIO.OffMeshConnection.exitPos)
  return exitpos_;
}
inline ::RecastIO::Vec3* OffMeshConnection::release_exitpos() {
  clear_has_exitpos();
  ::RecastIO::Vec3* temp = exitpos_;
  exitpos_ = NULL;
  return temp;
}
inline void OffMeshConnection::set_allocated_exitpos(::RecastIO::Vec3* exitpos) {
  delete exitpos_;
  exitpos_ = exitpos;
  if (exitpos) {
    set_has_exitpos();
  } else {
    clear_has_exitpos();
  }
  // @@protoc_insertion_point(field_set_allocated:RecastIO.OffMeshConnection.exitPos)
}

// repeated .RecastIO.Vec3 intermediatePos = 3;
inline int OffMeshConnection::intermediatepos_size() const {
  return intermediatepos_.size();
}
inline void OffMeshConnection::clear_intermediatepos() {
  intermediatepos_.Clear();
}
inline const ::RecastIO::Vec3& OffMeshConnection::intermediatepos(int index) const {
  // @@protoc_insertion_point(field_get:RecastIO.OffMeshConnection.intermediatePos)
  return intermediatepos_.Get(index);
}
inline ::RecastIO::Vec3* OffMeshConnection::mutable_intermediatepos(int index) {
  // @@protoc_insertion_point(field_mutable:RecastIO.OffMeshConnection.intermediatePos)
  return intermediatepos_.Mutable(index);
}
inline ::RecastIO::Vec3* OffMeshConnection::add_intermediatepos() {
  // @@protoc_insertion_point(field_add:RecastIO.OffMeshConnection.intermediatePos)
  return intermediatepos_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::RecastIO::Vec3 >&
OffMeshConnection::intermediatepos() const {
  // @@protoc_insertion_point(field_list:RecastIO.OffMeshConnection.intermediatePos)
  return intermediatepos_;
}
inline ::google::protobuf::RepeatedPtrField< ::RecastIO::Vec3 >*
OffMeshConnection::mutable_intermediatepos() {
  // @@protoc_insertion_point(field_mutable_list:RecastIO.OffMeshConnection.intermediatePos)
  return &intermediatepos_;
}

// required float radius = 4;
inline bool OffMeshConnection::has_radius() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void OffMeshConnection::set_has_radius() {
  _has_bits_[0] |= 0x00000008u;
}
inline void OffMeshConnection::clear_has_radius() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void OffMeshConnection::clear_radius() {
  radius_ = 0;
  clear_has_radius();
}
inline float OffMeshConnection::radius() const {
  // @@protoc_insertion_point(field_get:RecastIO.OffMeshConnection.radius)
  return radius_;
}
inline void OffMeshConnection::set_radius(float value) {
  set_has_radius();
  radius_ = value;
  // @@protoc_insertion_point(field_set:RecastIO.OffMeshConnection.radius)
}

// required uint32 areaType = 5;
inline bool OffMeshConnection::has_areatype() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void OffMeshConnection::set_has_areatype() {
  _has_bits_[0] |= 0x00000010u;
}
inline void OffMeshConnection::clear_has_areatype() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void OffMeshConnection::clear_areatype() {
  areatype_ = 0u;
  clear_has_areatype();
}
inline ::google::protobuf::uint32 OffMeshConnection::areatype() const {
  // @@protoc_insertion_point(field_get:RecastIO.OffMeshConnection.areaType)
  return areatype_;
}
inline void OffMeshConnection::set_areatype(::google::protobuf::uint32 value) {
  set_has_areatype();
  areatype_ = value;
  // @@protoc_insertion_point(field_set:RecastIO.OffMeshConnection.areaType)
}

// required uint32 flags = 6;
inline bool OffMeshConnection::has_flags() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void OffMeshConnection::set_has_flags() {
  _has_bits_[0] |= 0x00000020u;
}
inline void OffMeshConnection::clear_has_flags() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void OffMeshConnection::clear_flags() {
  flags_ = 0u;
  clear_has_flags();
}
inline ::google::protobuf::uint32 OffMeshConnection::flags() const {
  // @@protoc_insertion_point(field_get:RecastIO.OffMeshConnection.flags)
  return flags_;
}
inline void OffMeshConnection::set_flags(::google::protobuf::uint32 value) {
  set_has_flags();
  flags_ = value;
  // @@protoc_insertion_point(field_set:RecastIO.OffMeshConnection.flags)
}

// optional bool biDirectional = 7 [default = false];
inline bool OffMeshConnection::has_bidirectional() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void OffMeshConnection::set_has_bidirectional() {
  _has_bits_[0] |= 0x00000040u;
}
inline void OffMeshConnection::clear_has_bidirectional() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void OffMeshConnection::clear_bidirectional() {
  bidirectional_ = false;
  clear_has_bidirectional();
}
inline bool OffMeshConnection::bidirectional() const {
  // @@protoc_insertion_point(field_get:RecastIO.OffMeshConnection.biDirectional)
  return bidirectional_;
}
inline void OffMeshConnection::set_bidirectional(bool value) {
  set_has_bidirectional();
  bidirectional_ = value;
  // @@protoc_insertion_point(field_set:RecastIO.OffMeshConnection.biDirectional)
}

// -------------------------------------------------------------------

// SubModel

// required int32 submodelId = 1;
inline bool SubModel::has_submodelid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SubModel::set_has_submodelid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SubModel::clear_has_submodelid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SubModel::clear_submodelid() {
  submodelid_ = 0;
  clear_has_submodelid();
}
inline ::google::protobuf::int32 SubModel::submodelid() const {
  // @@protoc_insertion_point(field_get:RecastIO.SubModel.submodelId)
  return submodelid_;
}
inline void SubModel::set_submodelid(::google::protobuf::int32 value) {
  set_has_submodelid();
  submodelid_ = value;
  // @@protoc_insertion_point(field_set:RecastIO.SubModel.submodelId)
}

// optional bool disabled = 2;
inline bool SubModel::has_disabled() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SubModel::set_has_disabled() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SubModel::clear_has_disabled() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SubModel::clear_disabled() {
  disabled_ = false;
  clear_has_disabled();
}
inline bool SubModel::disabled() const {
  // @@protoc_insertion_point(field_get:RecastIO.SubModel.disabled)
  return disabled_;
}
inline void SubModel::set_disabled(bool value) {
  set_has_disabled();
  disabled_ = value;
  // @@protoc_insertion_point(field_set:RecastIO.SubModel.disabled)
}

// optional bool mover = 3;
inline bool SubModel::has_mover() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SubModel::set_has_mover() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SubModel::clear_has_mover() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SubModel::clear_mover() {
  mover_ = false;
  clear_has_mover();
}
inline bool SubModel::mover() const {
  // @@protoc_insertion_point(field_get:RecastIO.SubModel.mover)
  return mover_;
}
inline void SubModel::set_mover(bool value) {
  set_has_mover();
  mover_ = value;
  // @@protoc_insertion_point(field_set:RecastIO.SubModel.mover)
}

// optional bool nonsolid = 4;
inline bool SubModel::has_nonsolid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SubModel::set_has_nonsolid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SubModel::clear_has_nonsolid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SubModel::clear_nonsolid() {
  nonsolid_ = false;
  clear_has_nonsolid();
}
inline bool SubModel::nonsolid() const {
  // @@protoc_insertion_point(field_get:RecastIO.SubModel.nonsolid)
  return nonsolid_;
}
inline void SubModel::set_nonsolid(bool value) {
  set_has_nonsolid();
  nonsolid_ = value;
  // @@protoc_insertion_point(field_set:RecastIO.SubModel.nonsolid)
}

// -------------------------------------------------------------------

// NavigationMesh

// required int32 version = 1;
inline bool NavigationMesh::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NavigationMesh::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NavigationMesh::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NavigationMesh::clear_version() {
  version_ = 0;
  clear_has_version();
}
inline ::google::protobuf::int32 NavigationMesh::version() const {
  // @@protoc_insertion_point(field_get:RecastIO.NavigationMesh.version)
  return version_;
}
inline void NavigationMesh::set_version(::google::protobuf::int32 value) {
  set_has_version();
  version_ = value;
  // @@protoc_insertion_point(field_set:RecastIO.NavigationMesh.version)
}

// required .RecastIO.NavMeshParams navMeshParams = 2;
inline bool NavigationMesh::has_navmeshparams() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NavigationMesh::set_has_navmeshparams() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NavigationMesh::clear_has_navmeshparams() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NavigationMesh::clear_navmeshparams() {
  if (navmeshparams_ != NULL) navmeshparams_->::RecastIO::NavMeshParams::Clear();
  clear_has_navmeshparams();
}
inline const ::RecastIO::NavMeshParams& NavigationMesh::navmeshparams() const {
  // @@protoc_insertion_point(field_get:RecastIO.NavigationMesh.navMeshParams)
  return navmeshparams_ != NULL ? *navmeshparams_ : *default_instance_->navmeshparams_;
}
inline ::RecastIO::NavMeshParams* NavigationMesh::mutable_navmeshparams() {
  set_has_navmeshparams();
  if (navmeshparams_ == NULL) navmeshparams_ = new ::RecastIO::NavMeshParams;
  // @@protoc_insertion_point(field_mutable:RecastIO.NavigationMesh.navMeshParams)
  return navmeshparams_;
}
inline ::RecastIO::NavMeshParams* NavigationMesh::release_navmeshparams() {
  clear_has_navmeshparams();
  ::RecastIO::NavMeshParams* temp = navmeshparams_;
  navmeshparams_ = NULL;
  return temp;
}
inline void NavigationMesh::set_allocated_navmeshparams(::RecastIO::NavMeshParams* navmeshparams) {
  delete navmeshparams_;
  navmeshparams_ = navmeshparams;
  if (navmeshparams) {
    set_has_navmeshparams();
  } else {
    clear_has_navmeshparams();
  }
  // @@protoc_insertion_point(field_set_allocated:RecastIO.NavigationMesh.navMeshParams)
}

// repeated .RecastIO.Tile tiles = 3;
inline int NavigationMesh::tiles_size() const {
  return tiles_.size();
}
inline void NavigationMesh::clear_tiles() {
  tiles_.Clear();
}
inline const ::RecastIO::Tile& NavigationMesh::tiles(int index) const {
  // @@protoc_insertion_point(field_get:RecastIO.NavigationMesh.tiles)
  return tiles_.Get(index);
}
inline ::RecastIO::Tile* NavigationMesh::mutable_tiles(int index) {
  // @@protoc_insertion_point(field_mutable:RecastIO.NavigationMesh.tiles)
  return tiles_.Mutable(index);
}
inline ::RecastIO::Tile* NavigationMesh::add_tiles() {
  // @@protoc_insertion_point(field_add:RecastIO.NavigationMesh.tiles)
  return tiles_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::RecastIO::Tile >&
NavigationMesh::tiles() const {
  // @@protoc_insertion_point(field_list:RecastIO.NavigationMesh.tiles)
  return tiles_;
}
inline ::google::protobuf::RepeatedPtrField< ::RecastIO::Tile >*
NavigationMesh::mutable_tiles() {
  // @@protoc_insertion_point(field_mutable_list:RecastIO.NavigationMesh.tiles)
  return &tiles_;
}

// repeated .RecastIO.AxisAlignedBounds exclusionZone = 4;
inline int NavigationMesh::exclusionzone_size() const {
  return exclusionzone_.size();
}
inline void NavigationMesh::clear_exclusionzone() {
  exclusionzone_.Clear();
}
inline const ::RecastIO::AxisAlignedBounds& NavigationMesh::exclusionzone(int index) const {
  // @@protoc_insertion_point(field_get:RecastIO.NavigationMesh.exclusionZone)
  return exclusionzone_.Get(index);
}
inline ::RecastIO::AxisAlignedBounds* NavigationMesh::mutable_exclusionzone(int index) {
  // @@protoc_insertion_point(field_mutable:RecastIO.NavigationMesh.exclusionZone)
  return exclusionzone_.Mutable(index);
}
inline ::RecastIO::AxisAlignedBounds* NavigationMesh::add_exclusionzone() {
  // @@protoc_insertion_point(field_add:RecastIO.NavigationMesh.exclusionZone)
  return exclusionzone_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::RecastIO::AxisAlignedBounds >&
NavigationMesh::exclusionzone() const {
  // @@protoc_insertion_point(field_list:RecastIO.NavigationMesh.exclusionZone)
  return exclusionzone_;
}
inline ::google::protobuf::RepeatedPtrField< ::RecastIO::AxisAlignedBounds >*
NavigationMesh::mutable_exclusionzone() {
  // @@protoc_insertion_point(field_mutable_list:RecastIO.NavigationMesh.exclusionZone)
  return &exclusionzone_;
}

// repeated .RecastIO.OffMeshConnection offMeshConnection = 5;
inline int NavigationMesh::offmeshconnection_size() const {
  return offmeshconnection_.size();
}
inline void NavigationMesh::clear_offmeshconnection() {
  offmeshconnection_.Clear();
}
inline const ::RecastIO::OffMeshConnection& NavigationMesh::offmeshconnection(int index) const {
  // @@protoc_insertion_point(field_get:RecastIO.NavigationMesh.offMeshConnection)
  return offmeshconnection_.Get(index);
}
inline ::RecastIO::OffMeshConnection* NavigationMesh::mutable_offmeshconnection(int index) {
  // @@protoc_insertion_point(field_mutable:RecastIO.NavigationMesh.offMeshConnection)
  return offmeshconnection_.Mutable(index);
}
inline ::RecastIO::OffMeshConnection* NavigationMesh::add_offmeshconnection() {
  // @@protoc_insertion_point(field_add:RecastIO.NavigationMesh.offMeshConnection)
  return offmeshconnection_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::RecastIO::OffMeshConnection >&
NavigationMesh::offmeshconnection() const {
  // @@protoc_insertion_point(field_list:RecastIO.NavigationMesh.offMeshConnection)
  return offmeshconnection_;
}
inline ::google::protobuf::RepeatedPtrField< ::RecastIO::OffMeshConnection >*
NavigationMesh::mutable_offmeshconnection() {
  // @@protoc_insertion_point(field_mutable_list:RecastIO.NavigationMesh.offMeshConnection)
  return &offmeshconnection_;
}

// repeated .RecastIO.SubModel subModelInfo = 6;
inline int NavigationMesh::submodelinfo_size() const {
  return submodelinfo_.size();
}
inline void NavigationMesh::clear_submodelinfo() {
  submodelinfo_.Clear();
}
inline const ::RecastIO::SubModel& NavigationMesh::submodelinfo(int index) const {
  // @@protoc_insertion_point(field_get:RecastIO.NavigationMesh.subModelInfo)
  return submodelinfo_.Get(index);
}
inline ::RecastIO::SubModel* NavigationMesh::mutable_submodelinfo(int index) {
  // @@protoc_insertion_point(field_mutable:RecastIO.NavigationMesh.subModelInfo)
  return submodelinfo_.Mutable(index);
}
inline ::RecastIO::SubModel* NavigationMesh::add_submodelinfo() {
  // @@protoc_insertion_point(field_add:RecastIO.NavigationMesh.subModelInfo)
  return submodelinfo_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::RecastIO::SubModel >&
NavigationMesh::submodelinfo() const {
  // @@protoc_insertion_point(field_list:RecastIO.NavigationMesh.subModelInfo)
  return submodelinfo_;
}
inline ::google::protobuf::RepeatedPtrField< ::RecastIO::SubModel >*
NavigationMesh::mutable_submodelinfo() {
  // @@protoc_insertion_point(field_mutable_list:RecastIO.NavigationMesh.subModelInfo)
  return &submodelinfo_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace RecastIO

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_recast_2eproto__INCLUDED
