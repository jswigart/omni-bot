// This script contains useful utility scripts for performing common actions.

// offset for converted waypoint goals
Util.WaypointGoalOffset = Vector3(0,0,-24);

Util.AllTeamPlayers = 32;
Util.AllTeams = (1 << TEAM.AXIS) | (1 << TEAM.ALLIES); 
Util.AllClasses = (1 << CLASS.SOLDIER) | (1 << CLASS.MEDIC) |
	(1 << CLASS.ENGINEER) | (1 << CLASS.LIEUTENANT);
Util.FlagCarrier = "CLASS.ENGINEER";
Util.Sniper = "CLASS.SOLDIER";

Util.HaveTeam = { false, true, true, false, false };

Util.TeamNames =
{
	{ "", "", "" },
	{ "AXIS", "Axis", "axis" },
	{ "ALLIES", "Allies", "allies" },
};

Util.BotNames =
{ 
	{
		"", "", "", "", 
		"",
	},
	{
		"", "axis_soldier", "axis_medic", "axis_engineer", 
		"axis_lieutenant",
	},
	{
		"", "allies_soldier", "allies_medic", "allies_engineer", 
		"allies_lieutenant",
	},
};

Util.NoTimeLimit = "timelimit 0";
Util.TimeLimit1 = "timelimit 1";

///////////////////////////////////////////////////////////////////////////////
// cs: keeping this since other funcs call
Util.PlayerClassTable =
{
	CLASS.SOLDIER,
	CLASS.ENGINEER,
	CLASS.MEDIC,
	CLASS.LIEUTENANT,
};


//////////////////////////////////////////////////////////////////////////
// A table for referencing default goal priorities. Reference only

if ( Util.DefaultPriorities == null )
	{ Util.DefaultPriorities = table(); }

Util.DefaultPriorities["PLANT"] = 0.8;
Util.DefaultPriorities["DEFUSE"] = 1.0;
Util.DefaultPriorities["REVIVE"] = 1.0;
Util.DefaultPriorities["MOVER"] = 0.0;
Util.DefaultPriorities["MOUNTMG42"] = 0.55;
Util.DefaultPriorities["REPAIRMG42"] = 0.56;
Util.DefaultPriorities["CALLARTILLERY"] = 0.7;
Util.DefaultPriorities["ARTILLERY_S"] = 0.7;
Util.DefaultPriorities["ARTILLERY_D"] = 0.7;
Util.DefaultPriorities["CHECKPOINT"] = 0.6;
Util.DefaultPriorities["EXPLODE"] = 0.3;
Util.DefaultPriorities["PANZER"] = 0.6;
Util.DefaultPriorities["FLAME"] = 0.6;
Util.DefaultPriorities["VENOM"] = 0.6;

member numallies = 0;
member numaxis = 0;

///////////////////////////////////////////////////////////////////////////////
// The DebugBotAim function runs this thread on the bots.

member DebugBotAimThread = function( _targetpos )
{
	block( EVENT.SPAWNED );
	
	RTCWUtil.SetScriptControlled( true );
	RTCWUtil.EnableShooting( false );
	
	// Repeat until we get there.
	while(1)
	{
		print( "Going to " + _targetpos );
		RTCWUtil.GoTo( _targetpos );
		
		if( block(EVENT.GOAL_SUCCESS, EVENT.GOAL_FAILED) == EVENT.GOAL_SUCCESS )
		{
			break;
		}
	}
	
	RTCWUtil.SetDebugFlag( DEBUG.AIM, true );
			
};

///////////////////////////////////////////////////////////////////////////////
// This function adds 2 bots to the game, disables their 

member DebugBotAim = function( _range )
{
	// Pick a default range to use if none is provided.
	if( _range == null )
	{
		_range = 20;
	}

	print( "Range " + _range );
	
	KickAll();

	AddBot( TEAM.ALLIES, CLASS.SOLDIER );
	AddBot( TEAM.AXIS, CLASS.SOLDIER );
	
	// Get a target position for 2 bots.
	localHost = GetGameEntityFromId(0);
	localHostPos = localHost.GetPosition();
	localHostFacing = localHost.GetFacing();
	
	sleep(5.0);
		
	// calculate 2 points on each side of the localhost to send the bots to.
	aimPoints = table();
	aimPoints[0] = localHostPos + ( localHostFacing * _range );
	aimPoints[1] = localHostPos - ( localHostFacing * _range );
	
	print( "Creating bot threads." );
	iCurrentBot = 0;
	foreach ( gameId and bot in BotTable )
	{
		print( aimPoints[iCurrentBot] );
		bot:thread( RTCWUtil.DebugBotAimThread, aimPoints[iCurrentBot] );
		iCurrentBot += 1;
		if(iCurrentBot >= 2)
		{
			break;
		}
	}	
};

///////////////////////////////////////////////////////////////////////////////
//
member AddBotTester = function( team, class, name )
{
	// Add Tester bot
	sleep( 1 );
	AddBot(team, class, name);
	sleep( 1 );
	
	botPtr = Util.GetBotPointer( name );
	botId = Util.GetBotId( name );
	botstats = {}; 

	while ( !botstats.Health )
	{
		GetEntHealthAndArmor( botId, botstats );
		sleep( 1 );
	}
		
	return botPtr;
};

///////////////////////////////////////////////////////////////////////////////
//
member ClearMainGoals = function()
{
	SetAvailableMapGoals( TEAM.ALLIES, false, "PLANT.*" );
	SetAvailableMapGoals( TEAM.AXIS, false, "PLANT.*" );
	SetAvailableMapGoals( TEAM.ALLIES, false, "MOUNTMG42.*" );
	SetAvailableMapGoals( TEAM.AXIS, false, "MOUNTMG42.*" );
	SetAvailableMapGoals( TEAM.ALLIES, false, "MOVER.*" );
	SetAvailableMapGoals( TEAM.AXIS, false, "MOVER.*" );
	SetAvailableMapGoals( TEAM.ALLIES, false, "CHECKPOINT.*" );
	SetAvailableMapGoals( TEAM.AXIS, false, "CHECKPOINT.*" );
	SetAvailableMapGoals( TEAM.ALLIES, false, "FLAG.*" );
	SetAvailableMapGoals( TEAM.AXIS, false, "FLAG.*" );
};

///////////////////////////////////////////////////////////////////////////////
//
member ClearSecondaryGoals = function()
{
	SetAvailableMapGoals( TEAM.ALLIES, false, "REPAIR.*" );
	SetAvailableMapGoals( TEAM.AXIS, false, "REPAIR.*" );
	SetAvailableMapGoals( TEAM.ALLIES, false, ".*ARTILLERY.*" );
	SetAvailableMapGoals( TEAM.AXIS, false, ".*ARTILLERY.*" );
};

///////////////////////////////////////////////////////////////////////////////
//
member WarpTo = function( _params )
{
	if ( !CheatsEnabled() )
	{
		print("^1cheats must be enabled to use this command");
		print("type /devmap", GetMapName(), "in console");
		return;
	}

	found = false;
	goalname = _params[0];
	goal = GetGoal( goalname );

	if ( goal )
	{
		found = true;
		goalpos = goal.GetPosition(); 
		s = "setviewpos " + goalpos[0] + " " + goalpos[1] + " " + goalpos[2] + " " + " 0";
		print(s);
		ExecCommandOnClient(Util.GetPlayerEntity(), s);
	}
	else //try wp name
	{
		wp = Util.WpNameInfo(_params[0]);
		if ( wp.position )
		{
			found = true;
			s = "setviewpos " + wp.position[0] + " " + wp.position[1] + " " + wp.position[2] + " " + " 0";
			print(s);
			ExecCommandOnClient(Util.GetPlayerEntity(), s);
		} 
		//print("WarpTo: Invalid Goal"); 
	}

	if ( !found )
		{ print( "^1member Warpto: Invalid goal name or waypoint name^2"); }
};

///////////////////////////////////////////////////////////////////////////////
//
member WarpTestBot = function( _params )
{
	if ( !CheatsEnabled() )
	{
		print("^1cheats must be enabled to use this command");
		print("type /devmap", GetMapName(), "in console");
		return;
	}

	b = Util.GetBotByName("testbot");
	
	if ( !b )
	{
		print("^1no testbot found");
		return;
	}
	
	found = false;

	wp = Util.WpNameInfo(_params[0]);
	if ( wp.position )
	{
		found = true;
		s = "setviewpos " + wp.position[0] + " " + wp.position[1] + " " + wp.position[2] + " " + " 0";
		print(s);
		ExecCommandOnClient(b.GetGameEntity(), s);
		yield();yield();
		ExecCommandOnClient(Util.GetPlayerEntity(), "say_team bot come");
		
	} 

	if ( !found )
		{ print( "^1member WarpTestBot: Invalid waypoint name^2"); }
};

///////////////////////////////////////////////////////////////////////////////
//
member RollCall = function()
{
	foreach ( id and bot in BotTable )
	{
		print(bot.Name);
		print("TEAM: ", Util.TeamName(bot.GetTeam()));
		print("CLASS: ",Util.ClassName(bot.GetClass()));
		print("MOVESKILL: ", bot.moveskill);
		print("ENTITY: ",bot);
		print("^7-----------------------");
	}
};

///////////////////////////////////////////////////////////////////////////////
//
member CountClass = function( team, class )
{
	count = 0;
	foreach ( id and bot in BotTable )
	{
		// added injuredplayer check as a hack until there is a good method for
		// getting ungibbed players real class. this is basically
		// preventing multiple engineers being added with the 
		// manageengineers thread. sigh			
		if ( bot.GetTeam() == team && bot.GetClass() == class || bot.GetClass() == CLASS.INJUREDPLAYER  )
			{ count += 1; }				
	}
	
	return count;
};

///////////////////////////////////////////////////////////////////////////////
//
member ChangeClass = function( team, originalclass, newclass, revert, maxbots )
{
	numbots = 0;

	foreach ( id and bot in BotTable )
	{
		if ( !GetEntFlags(bot.GetGameEntity(), ENTFLAG.CARRYINGGOAL) 
			&& bot.GetTeam() == team  )
		{
			if ( bot.PrimaryClass == null )
				{ bot.PrimaryClass = bot.GetClass(); }

			if ( bot.PrimaryClass == originalclass && !revert && !bot.ClassChanged )
			{
				if ( numbots < maxbots )
				{
					numbots += 1;
					bot.ClassChanged = true;
					bot.ChangeClass(newclass);
				}
			}

			if ( bot.ClassChanged && revert && bot.PrimaryClass == originalclass 
				&& bot.GetClass() == newclass )
			{
				bot.ClassChanged = false;
				bot.ChangeClass(bot.PrimaryClass);
			} 
		}
	}
};

///////////////////////////////////////////////////////////////////////////////
//
member NoSnipeWeapons =
{
	WEAPON.PANZERFAUST,
	WEAPON.VENOM,
	WEAPON.FLAMETHROWER,		
};

///////////////////////////////////////////////////////////////////////////////
//
member NoSnipe = function (bot)
{
	if ( bot.GetClass() != CLASS.SOLDIER ) { return; }

	if ( bot.HasWeapon(WEAPON.MAUSER) )
	{
		weap = RandInt(0, tableCount(RTCWUtil.NoSnipeWeapons) - 1);
		bot.ChangePrimaryWeapon( RTCWUtil.NoSnipeWeapons[weap] );			
	}
};

///////////////////////////////////////////////////////////////////////////////
//
member StopSniping = function(team)
{
	foreach ( id and bot in BotTable )
	{
		if ( team && bot.GetTeam() != team )
			{ continue; }

		RTCWUtil.NoSnipe(bot);
	}
};

///////////////////////////////////////////////////////////////////////////////
//
member SetPrimaryGoals = function(priority)
{
	SetGoalPriority( "CAPPOINT_.*", priority );
	SetGoalPriority( "PLANT_.*", priority - 0.08f );			
	SetGoalPriority( "CHECKPOINT_.*", priority - 0.1f );
	SetGoalPriority( "FLAG_.*", priority - 0.15f, 0, 0, true );
	SetGoalPriority( "FLAGRETURN_.*", 1.0, 0, 0, true  );
};

///////////////////////////////////////////////////////////////////////////////
//
member LimitToClass = function(goalname, team, class1, class2, class3)
{
	foreach ( id and class in Util.PlayerClassTable )
	{			
		if ( class == class1 || class == class2 || class == class3 )
			{ continue; }
		
		SetGoalPriority( goalname, 0.0, team, class);
	}
};

///////////////////////////////////////////////////////////////////////////////
//
member ExcludeClass = function( goalname, team, class1, class2, class3, class4 )
{
	foreach ( id and class in Util.PlayerClassTable )
	{
		if ( class == class1 || class == class2 || class == class3 || class == class4 )
			{ SetGoalPriority( goalname, 0.0, team, class); }
	}
};

///////////////////////////////////////////////////////////////////////////////
//
member SelectWeapon = function(bot, w, isFog)
{
	class = bot.GetClass();

	if ( class == CLASS.SOLDIER ) 
	{
		if ( w == WEAPON.PANZERFAUST ||
			w == WEAPON.MAUSER ||
			w == WEAPON.VENOM ||
			w == WEAPON.FLAMETHROWER )
		{
			bot.ChangePrimaryWeapon(w);
			if ( w == WEAPON.MAUSER && !isFog)
			{
				if ( bot.MaxViewDistance < 5000 )
					{ bot.MaxViewDistance = bot.MaxViewDistance * 2; }
				else
					{ bot.MaxViewDistance = 10000; }
			}
		}
	}
	else if ( class == CLASS.LIEUTENANT )
	{
		if ( w == WEAPON.MP40 ||
			w == WEAPON.THOMPSON ||
			w == WEAPON.STEN )
		{
			bot.ChangePrimaryWeapon(w);
		}
	}
};

///////////////////////////////////////////////////////////////////////////////
//
member SelectSoldierWeapons = function( team, bot, weap1, weap2, weap3 )
{
	if ( bot.GetClass() != CLASS.SOLDIER || ( team != 0 && bot.GetTeam() != team ) )
		{ return; }
		
	wt = table();
	
	if ( weap1 )
		{ Util.AddToTable( wt, weap1 ); }
	if ( weap2 )
		{ Util.AddToTable( wt, weap2); }
	if ( weap3 )
		{ Util.AddToTable(wt, weap3); }
		
	weap = RandInt(0, tableCount(wt) - 1);
	bot.ChangePrimaryWeapon( wt[weap] );
};

///////////////////////////////////////////////////////////////////////////////
//
member SwitchSoldierWeapons = function( team, weap1, weap2, weap3 )
{
	foreach ( id and bot in BotTable )
	{
		RTCWUtil.SelectSoldierWeapons(team, bot, weap1, weap2, weap3);
	}
};	

///////////////////////////////////////////////////////////////////////////////
//
member SwitchWeapon = function( w )
{
	foreach ( id and bot in BotTable )
	{
		RTCWUtil.SelectWeapon(bot, w);
	}
};

///////////////////////////////////////////////////////////////////////////////
//
member SetDualObjective = function(bot, otherspawn)
{
	if ( !otherspawn )
		{ otherspawn = 0; }
			
	team = bot.GetTeam();
	plantgoal = RTCWUtil.IsPlantGoalAvailable();
	
	if ( !Map.Defend )
		{ Map.Defend = table(); }
		
	// users
	if ( !Map.Defend.AlliesUsers )
		{ Map.Defend.AlliesUsers = table(); }
		
	if ( !Map.Defend.AxisUsers )
		{ Map.Defend.AxisUsers = table(); }	

	// tables to hold waypoint names 
	if ( !Map.Defend.Allies )
		{ Map.Defend.Allies = table(); }
		
	if ( !Map.Defend.Axis )
		{ Map.Defend.Axis = table(); }

	// counters for number of users
	if ( !Map.Defend.AlliesDefenders )
		{ Map.Defend.AlliesDefenders = 0; }
		
	if ( !Map.Defend.AxisDefenders )
		{ Map.Defend.AxisDefenders = 0; }			
	
	if ( team == TEAM.AXIS )
	{
		RTCWUtil.numaxis += 1;
		//every other bot will spawn close to defense until max defenders is reached
		if ( Map.Defend.Axis && Map.Defend.AxisDefenders < Map.Defend.MaxAxisDefenders 
			&& !bot.HasWeapon(WEAPON.MAUSER) )
		{
			if ( RTCWUtil.numaxis % 2 == 0 )
			{
				Map.Defend.AxisUsers[ bot.GetGameId() ] = true;
				bot.AddScriptGoal("DualObjective");
				
				//first bot defending will switch to crucial class
				if ( Map.Defend.AxisDefenders == 0 && Map.Defend.CrucialClass )
					{ bot.ChangeClass(Map.Defend.CrucialClass); }
					
				if ( Map.Defend.AxisSpawnPt )
					{ bot.ChangeSpawnPoint( Map.Defend.AxisSpawnPt ); }
				else
					{ bot.ChangeSpawnPoint( 1 ); }
					
				Map.Defend.AxisDefenders += 1;
			}
			else
			{
				// make sure there is an offensive engineer if required
				if ( RTCWUtil.numaxis == 1 && plantgoal )
				{
					bot.ChangeClass(CLASS.ENGINEER);
				}
				bot.ChangeSpawnPoint( otherspawn ); 
			}
		}
		else
		{
			bot.ChangeSpawnPoint( otherspawn );
		}
	}
	else if ( team == TEAM.ALLIES )
	{
		RTCWUtil.numallies += 1;
		//every other bot will spawn close to defense until max defenders is reached
		if ( Map.Defend.Allies && Map.Defend.AlliesDefenders < Map.Defend.MaxAlliesDefenders 
			&& !bot.HasWeapon(WEAPON.MAUSER) )
		{
			if ( RTCWUtil.numallies % 2 == 0 )
			{
				Map.Defend.AlliesUsers[ bot.GetGameId() ] = true;
				bot.AddScriptGoal("DualObjective");
				
				//first bot defending will switch to crucial class
				if ( Map.Defend.AlliesDefenders == 0 && Map.Defend.CrucialClass )
					{ bot.ChangeClass(Map.Defend.CrucialClass); }
					
				if ( Map.Defend.AlliesSpawnPt )
					{ bot.ChangeSpawnPoint( Map.Defend.AlliesSpawnPt ); }						
				else
					{ bot.ChangeSpawnPoint( 2 ); }
					
				Map.Defend.AlliesDefenders += 1;
			}
			else
			{
				// make sure there is an offensive engineer if required
				if ( RTCWUtil.numallies == 1 && plantgoal )
				{
					bot.ChangeClass(CLASS.ENGINEER);
				}
				bot.ChangeSpawnPoint( otherspawn ); 
			}
		}
		else
		{
			bot.ChangeSpawnPoint( otherspawn );
		}		
	}
};

///////////////////////////////////////////////////////////////////////////////
// s = bool suicide, p = bool persistent ( keep it set even after spawn )
member SetSuicide = function( team, class, s, p )
{
	foreach ( id and bot in BotTable )
	{
		if ( bot.GetTeam() == team && bot.GetClass() == class )
		{
			bot.Suicide(s, p);
		}
	}
};	

member SetTeamSuicide = function( team, s, p )
{
	foreach ( id and bot in BotTable )
	{
		if ( bot.GetTeam() == team )
		{
			bot.Suicide(s, p);
		}
	}
};	

member BotDisableCombatCrouch = function( bot, crouch )
{
	bot.DontCombatCrouch = crouch;
};

member TeamDisableCombatCrouch = function( team, crouch )
{
	foreach ( id and bot in BotTable )
	{
		if ( bot.GetTeam() == team )
		{
			bot.DontCombatCrouch = crouch;
		}
	}
};

member IsPlantGoalAvailable = function()
{
	goals = Util.GoalTable();
	
	foreach ( id and goal in goals )
	{
		n = goal.GetName();
		
		if( n.Find("PLANT") == 0 )
		{
			if ( goal.IsAvailable(TEAM.AXIS) || goal.IsAvailable(TEAM.ALLIES) )
			{
				return true;
			}
		}
	}
	
	// no plant goals available
	return false;
};

member ClassesByTeam = function(team)
{
	t = table();
	t.numMedics = 0.00;
	t.numLieutenants = 0.00;
	t.numSoldiers = 0.00;
	t.numEngineers = 0.00;
	t.numBots = ToFloat(Server.Team[ team ].NumBots);
	
	foreach (id and bot in BotTable)
	{
		if ( bot.GetTeam() == team )
		{
			class = bot.GetClass();
			
			if ( class == CLASS.SOLDIER )
			{
				t.numSoldiers += 1;
			}
			
			if ( class == CLASS.LIEUTENANT )
			{
				t.numLieutenants += 1;
			}

			if ( class == CLASS.MEDIC )
			{
				t.numMedics += 1;
			}

			if ( class == CLASS.ENGINEER )
			{
				t.numEngineers += 1;
			}					
		}
	}
	
	return t;
};

member SwitchHeavyClassBotToEng = function(team)
{
	t = RTCWUtil.ClassesByTeam(team);
	
	if ( t.numSoldiers > 1 && t.numSoldiers >= t.numMedics && t.numSoldiers >= t.numLieutenants )
	{
		heavyClass = CLASS.SOLDIER;
	}
	else if ( t.numLieutenants > 1 && t.numLieutenants >= t.numMedics )
	{
		heavyClass = CLASS.LIEUTENANT;
	}
	else if ( t.numMedics > 1 && t.numMedics > t.numLieutenants )
	{
		heavyClass = CLASS.MEDIC;
	}
	
	if ( !heavyClass )
	{
		if ( t.numLieutenants > 0 ) {
			heavyClass = CLASS.LIEUTENANT;
		}
		else if ( t.numSoldiers > 0 ) {
			heavyClass = CLASS.SOLDIER;
		}
		else if ( t.numMedics > 0 ) {
			heavyClass = CLASS.MEDIC;
		}			
	}

	foreach ( id and bot in BotTable )
	{
		if ( bot.GetTeam() == team and bot.GetClass() == heavyClass && t.numEngineers < 1)
		{
			bot.ChangeClass(CLASS.ENGINEER);
			t.numEngineers += 1;
		}
	}
};

member SwitchEngBotToLightClass = function(team, balance)
{
	t = RTCWUtil.ClassesByTeam(team);
	
	foreach ( id and bot in BotTable )
	{
		if ( bot.GetTeam() == team && bot.GetClass() == CLASS.ENGINEER )
		{
			if ( balance && (t.numEngineers / t.numBots <= 0.17) ) {
				continue;
			}
			
			if ( t.numMedics < 1 ) {
				lightClass = CLASS.MEDIC;
				t.numMedics += 1;
			}
			else if ( t.numLieutenants < 1 ) {
				lightClass = CLASS.LIEUTENANT;
				t.numLieutenants += 1;
			}
			else if ( t.numSoldiers < 1 ) {
				lightClass = CLASS.SOLDIER;
				t.numSoldiers += 1;
			}
			
			if ( !lightClass ) {
				//only lt or medic since we know there is a soldier at this point
				if ( t.numMedics <= t.numLieutenants ) {
					lightClass = CLASS.MEDIC;
					t.numMedics += 1;
				}
				else {
					lightClass = CLASS.LIEUTENANT;
					t.numLieutenants += 1;
				}
			}
			
			if( lightClass ) {
				bot.ChangeClass(lightClass);
			}
			
			// default to panzer unless specified since its the only weap thats never a bad choice
			if ( lightClass == CLASS.SOLDIER ) {
				if ( !Map || !Map.PreferredSoldierWeapon ) {
					bot.ChangePrimaryWeapon(WEAPON.PANZERFAUST);
				}
				else {
					bot.ChangePrimaryWeapon(Map.PreferredSoldierWeapon);
				}
			}
			
			t.numEngineers -= 1;
			lightClass = null;
		}
	}
};

member BalanceEngineers = function(team)
{
	t = RTCWUtil.ClassesByTeam(team);
	
	if (!Map || !Map.Defend || (Map.Defend.CrucialClass && Map.Defend.CrucialClass != CLASS.ENGINEER) )
	{
		if ( t.numEngineers == 1 && t.numBots < 6 ) {
			return;
		}
		
		if ( (t.numEngineers / t.numBots) > 0.17 )
		{
			RTCWUtil.SwitchEngBotToLightClass(team, true);
		}
	}
};
		
member ManageEngineers = function(delay)
{
	while(1)
	{
		if ( RTCWUtil.IsPlantGoalAvailable() )
		{
			// make sure each team has an engineer
			if ( RTCWUtil.CountClass(TEAM.AXIS, CLASS.ENGINEER) < 1 )
			{
				RTCWUtil.SwitchHeavyClassBotToEng(TEAM.AXIS);
			}
			else
			{
				RTCWUtil.BalanceEngineers(TEAM.AXIS);
			}
			
			if ( RTCWUtil.CountClass(TEAM.ALLIES, CLASS.ENGINEER) < 1 )
			{
				RTCWUtil.SwitchHeavyClassBotToEng(TEAM.ALLIES);
			}
			else
			{
				RTCWUtil.BalanceEngineers(TEAM.ALLIES);
			}
		}
		else // no plant goals = no engineers
		{
			if ( RTCWUtil.CountClass(TEAM.AXIS, CLASS.ENGINEER) > 0 )
			{
				RTCWUtil.SwitchEngBotToLightClass(TEAM.AXIS);
			}
			
			if ( RTCWUtil.CountClass(TEAM.ALLIES, CLASS.ENGINEER) > 0 )
			{
				RTCWUtil.SwitchEngBotToLightClass(TEAM.ALLIES);
			}	
		}
		
		sleep(delay);
	}
};

member IsTeamDead = function(team)
{
	// loop through the reserved player ents since there is no team table stored
	for ( i = 0; i < 64; i = i + 1 )
	{	
		if(GetEntTeam(i) == team && !GetEntFlags(i, ENTFLAG.DEAD) && GetEntClass(i) != CLASS.INJUREDPLAYER)
		{
			return false;
		}
	}
	
	return true;
};

member IsTeamClassDead = function(team, class)
{
	// loop through the reserved player ents since there is no team table stored
	for ( i = 0; i < 64; i = i + 1 )
	{	
		cls = GetEntClass(i);
		
		if ( cls != class ) {
			continue;
		}
		
		if(GetEntTeam(i) == team && !GetEntFlags(i, ENTFLAG.DEAD) && cls != CLASS.INJUREDPLAYER)
		{
			return false;
		}
	}
	
	return true;
};

///////////////////////////////////////////////////////////////////////////////
//
member ChangeSpawnNoDefenders = function(team, spawn, numbots)
{
	c = 0;
	foreach (id and bot in BotTable)
	{
		if ( team == TEAM.AXIS && Map.Defend.AxisUsers[ bot.GetGameId() ] == true )
		{
			continue;
		}
		
		if ( team == TEAM.ALLIES && Map.Defend.AlliesUsers[ bot.GetGameId() ] == true )
		{
			continue;
		}			
		
		if ( bot.GetTeam() == team )
		{
			bot.ChangeSpawnPoint( spawn );
			bot.ChangedSpawn = true;
			
			c += 1;
			if ( numbots && c >= numbots ) { return; }
		}
	}
};

///////////////////////////////////////////////////////////////////////////////
//
member TraceArty = function(usePlayer)
{
	dist = null;
	radius = 200;
	playerEnt = Util.GetPlayerEntity();
	playerPos = GetEntPosition(playerEnt);
	foundGoal = null;
	spots = table();
	targets = table();
	sourceOffset = Vector3(0,0,64);
	
	if ( !usePlayer )
	{
		GetGoals(spots, 0, "CALLART.*");		
		foreach ( id and mapgoal in spots )
		{
			evalDist = Util.Distance(mapgoal.GetPosition(), playerPos);
			if ( evalDist < radius )
			{
				if ( !dist || evalDist < dist )
				{
					dist = evalDist;
					foundGoal = mapgoal;
				}				
			}
		}
	}
	
	if (foundGoal || usePlayer)
	{
		if ( !usePlayer )
		{
			print("RTCWUtil.TraceArty: Selected", foundGoal.GetName());
		}
		else
		{
			print("RTCWUtil.TraceArty: Tracing from", GetEntName(playerEnt), "^2");
		}
		GetGoals(targets, 0, "ARTILLERY.*");
		
		if ( tableCount(targets) > 0 )
		{
			if ( !usePlayer )
			{
				sourcePos = foundGoal.GetPosition();
			}
			else
			{
				sourcePos = GetEntPosition(playerEnt) - Vector3(0,0,24);
			}
			
			foreach ( id and targetgoal in targets )
			{
				targetPos = targetgoal.GetPosition();
				targetName = targetgoal.GetName();
				
				tr = TraceLine(sourcePos + sourceOffset, targetPos, null, TRACE.SHOT, playerEnt, false);
				if ( tr.fraction < 1 ) 
				{
					print("RTCWUtil.TraceArty: ^1No line of sight to", targetName, "^2");
					DrawDebugLine(sourcePos + sourceOffset, targetPos, COLOR.RED, 30);
				}
				else
				{
					print("RTCWUtil.TraceArty: ^2Has line of sight to", targetName);
					DrawDebugLine(sourcePos + sourceOffset, targetPos, COLOR.GREEN, 30);
				}
			}
		}
		else
		{
			print("RTCWUtil.TraceArty: No Arty Targets");
		}
	}
	else
	{ 
		print("RTCWUtil.TraceArty: No Arty Goal Close Enough"); 
	}
};

///////////////////////////////////////////////////////////////////////////////
//DEPRECATE
member RandomSpawn = function( team, spawn )
{
	Util.MapDeprecateMessage( "RTCWUtil.RandomSpawn", "Util.RandomSpawn" );
	foreach ( id and bot in BotTable )
	{
		if ( !bot.ChangedSpawn && bot.GetTeam() == team )
		{
			if ( RandInt( 0, 1 ) < 1 )
			{
				bot.ChangeSpawnPoint( spawn );
				bot.ChangedSpawn = true;
			}
		}
	}
};
	
///////////////////////////////////////////////////////////////////////////////
//DEPRECATE
member ChangeSpawn = function( team, spawn, numbots )
{
	Util.MapDeprecateMessage( "RTCWUtil.ChangeSpawn", "Util.ChangeSpawn" );
	c = 0;
	foreach ( id and bot in BotTable )
	{
		if ( bot.GetTeam() == team )
		{
			bot.ChangeSpawnPoint( spawn );
			bot.ChangedSpawn = true;
			
			c += 1;
			
			if ( numbots && c >= numbots )
				{ return; }
		}
	}
};

///////////////////////////////////////////////////////////////////////////////
//DEPRECATE 
member EnableGoal = function( goal )
{
	Util.MapDeprecateMessage( "RTCWUtil.EnableGoal", "Util.EnableGoal" );
	SetAvailableMapGoals( 0, true, goal );
};

///////////////////////////////////////////////////////////////////////////////
//DEPRECATE 
member LimitGoal = function( team, goal )
{
	Util.MapDeprecateMessage( "RTCWUtil.LimitGoal", "Util.LimitGoal" );
	SetAvailableMapGoals( 0, false, goal );
	SetAvailableMapGoals( team, true, goal );
};
	
///////////////////////////////////////////////////////////////////////////////
//DEPRECATE
member DisableGoal = function( goal, routes )
{
	Util.MapDeprecateMessage( "RTCWUtil.DisableGoal", "Util.DisableGoal" );
	SetAvailableMapGoals( 0, false, goal );	

	if (routes) 
	{
		SetAvailableMapGoals( 0, true, "ROUTE_.*" );
	}
};

///////////////////////////////////////////////////////////////////////////////
//DEPRECATE
member CountTeam = function( team )
{
	Util.MapDeprecateMessage( "RTCWUtil.CountTeam", "Server.Team[ teamId ].NumPlayers" );
	count = 0;
	foreach ( id and bot in BotTable )
	{
		if ( bot.GetTeam() == team )
			{ count += 1; }
	}
	
	return count;
};

///////////////////////////////////////////////////////////////////////////////
//DEPRECATE
member OneBotSayTeam = function(team, msg)
{
	Util.MapDeprecateMessage( "RTCWUtil.OneBotSayTeam", "Util.OneBotSayTeam" );
	foreach (id and bot in BotTable)
	{
		if ( bot.GetTeam() == team )
		{
			bot.SayTeam(msg);
			return;
		}
	}
};

///////////////////////////////////////////////////////////////////////////////
//DEPRECATE
member OneBotVSayTeam = function(team, vchat)
{
	Util.MapDeprecateMessage( "RTCWUtil.OneBotVSayTeam", "Util.OneBotVSayTeam" );
	foreach (id and bot in BotTable)
	{
		if ( bot.GetTeam() == team )
		{
			bot.SayVoice(vchat);
			return;
		}
	}
};

///////////////////////////////////////////////////////////////////////////////
//DEPRECATE
member ShowActiveGoals = function(routes)
{
	Util.MapDeprecateMessage( "RTCWUtil.ShowActiveGoals", "Util.ShowActiveGoals" );
	Util.ShowActiveGoals(routes);
};
