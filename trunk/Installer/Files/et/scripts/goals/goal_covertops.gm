this.Name = "CovertOps";
this.Parent = "HighLevel";
this.AlwaysRecieveEvents = true;
this.SkipGetPriorityWhenActive = true;
this.AutoAdd = true;
this.Debug = false;

this.LimitToClass(CLASS.COVERTOPS);

// some states
this.GOTO_TARGET = 1;
this.GIB_TARGET = 2;
this.STEAL_UNIFORM = 3;
this.SPOT_MINES = 4;
this.STEALTH = 5;
this.SEARCH_FOR_CORPSE = 6;

this.Initialize = function()
{
	this.State = this.SPOT_MINES;
	this.UpdateDebugString();
};

this.OnSpawn = function()
{
	this.State = this.SPOT_MINES;
	this.UpdateDebugString();
};

this.GetPriority = function()
{
	while(1)
	{
		delay = RandInt(15, 45);
		if ( this.State == this.SPOT_MINES )
		{
			if ( this.Debug ) { this.Bot.Say("spot mine evaluation"); }
			if ( !this.Bot.HasEntityFlag(ENTFLAG.INWATER) && RandInt(0,10) < 2 && !this.Bot.GetVelocity().IsZero() && !this.Bot.HasTarget() ) {
				this.AddWeaponRequest(Priority.High, WEAPON.BINOCULARS );
				sleep(0.5);
				this.Bot.HoldButton(BTN.ATTACK1, 3);
				binocTime = 0;
				while( binocTime < 3 && !this.Bot.HasTarget() ) {
					sleep(1);
					binocTime += 1;
				}
				this.ReleaseWeaponRequest();
			}

			sleep(delay);

			// if it's still a spot mines state, toggle it to search for corpse (if not already disguised)
			if ( this.State == this.SPOT_MINES && !this.Bot.HasAnyEntityFlag(ENTFLAG.DISGUISED) ) {
				this.UpdateDebugString();
				this.State = this.SEARCH_FOR_CORPSE;
			}
			else {
				sleep(delay); // double it
			}
		}
		else if ( this.State == this.SEARCH_FOR_CORPSE ) {
			if ( this.Debug ) { this.Bot.Say("searching for corpse"); }
			corpse = ETUtil.FindUsableCorpse(this.Bot, 1000);
			if ( corpse ) {
				this.State = this.STEAL_UNIFORM;
				this.TargetPosition = GetEntPosition(corpse);
				this.Priority = 1.0;
			}
			else {
				this.State = this.SPOT_MINES; // toggle it back
				this.UpdateDebugString();
			}

			sleep(delay);
		}

		sleep(1);
	}
};

this.Update = function()
{
	while(1)
	{
		this.UpdateDebugString();
		switch(this.State)
		{
			case this.GOTO_TARGET:
			{
				if ( this.Debug ) {
					this.Bot.Say("going to gib!");
				}

				this.UpdateGotoTarget();
			}
			case this.GIB_TARGET:
			{
				if ( this.Debug ) {
					this.Bot.Say("gibbing!");
				}
				this.UpdateGib();
			}
			case this.STEAL_UNIFORM:
			{
				if ( this.Debug ) {
					this.Bot.Say("stealing uniform!");
				}
				this.UpdateStealUniform();
			}
			case this.STEALTH:
			{
				if ( this.Debug ) {
					this.Bot.Say("stealth!");
				}
				this.UpdateStealth();
			}
			default:
			{
				this.Finished();
			}
		}
		yield();
	}
};

this.UpdateGotoTarget = function()
{
	if ( this.TargetEntity )
	{
		// did it move?
		checkPosition = GetEntPosition(this.TargetEntity);
		
		// oops, it's not valid anymore so bail
		if ( !checkPosition ) {
			this.Finished();
		}

		// target position starts as null so this is guaranteed to run once
		if ( checkPosition != this.TargetPosition ) {
			this.TargetPosition = checkPosition;

			offsetPos = this.TargetPosition + Vector3(24,24,0);
			if (this.Goto(offsetPos, 64.0) == EVENT.PATH_SUCCESS) {
				// can't do this dynamically. bad waypoints break it. repath if its too far
				if ( DistanceBetween(this.TargetEntity, this.TargetPosition) > 64 ) {
					return;
				}
				this.State = this.GIB_TARGET;
				return;
			}
			else {
				this.Finished();
			}
		}
	}
	else
	{
		this.Finished();
	}
};

this.UpdateGib = function()
{
	yield();

	if ( this.Bot.HasTarget() ) {
		this.Finished();
	}

	// already gibbed?
	if (GetEntFlags(this.TargetEntity, ENTFLAG.LIMBO)) {
		this.State = this.STEAL_UNIFORM;
		return;
	}

	this.Bot.HoldButton(BTN.CROUCH, 99);
	this.AddAimRequest(Priority.High, "position", this.TargetPosition + Vector3(0,0,-12));

	this.AddWeaponRequest(Priority.High, WEAPON.KNIFE);
	//this.BlockForWeaponChange( WEAPON.KNIFE );

	// cs: weapon request for knife appears to be failing in some cases
	sleep(0.25);

	timeout = 0;
	while( timeout < 70 && !GetEntFlags(this.TargetEntity, ENTFLAG.LIMBO) ) {
		this.Bot.MoveTowards(this.TargetPosition + Vector3(12,12,0));
		this.Bot.HoldButton(BTN.ATTACK1, 0.5 );
		yield();
		timeout += 1;
	}

	this.ReleaseWeaponRequest();

	if (GetEntFlags(this.TargetEntity, ENTFLAG.LIMBO)) {
		this.State = this.STEAL_UNIFORM;
	}
	else {
		this.Finished();
	}
};

this.UpdateStealUniform = function()
{
	yield();
	if ( this.TargetPosition )
	{
		if ( this.Bot.HasTarget() ) {
			this.Finished();
		}

		this.Bot.HoldButton(BTN.CROUCH, 99);
		this.AddAimRequest(Priority.High, "position", this.TargetPosition + Vector3(0,0,-12));

		this.Bot.HoldButton(BTN.USE, 99);

		botEnt = this.Bot.GetGameEntity();
		timeout = 0;
		while(timeout <= 180 && !GetEntFlags(botEnt, ENTFLAG.DISGUISED)){
			this.Bot.MoveTowards(this.TargetPosition + Vector3(24,24,0));
			yield();
			timeout += 1;
		}

		this.Bot.ReleaseButton(BTN.CROUCH, BTN.USE);
		this.ReleaseAimRequest();

		if ( GetEntFlags(botEnt, ENTFLAG.DISGUISED) ) {
			if ( this.Debug ) {
				this.Bot.Say("In Disguise!");
			}
			this.State = this.STEALTH;
		}
		else {
			this.Finished(); // it failed
		}
	}
	else {
		this.Finished();
	}
};

this.UpdateStealth = function()
{
	// reduce priority so they can go do regular goals while in disguise
	// but keep it a bit higher priority than typical camp goals
	// cs: testing a lower priority per Palota's request.
	// so let's have it lower than camp goals. goal_indisguise is now changed
	// to have them only ignore targets if they are not at a camp spot ( velocity > 0 ).
	//this.Priority = 0.62;
	this.Priority = 0.4;

	botEnt = this.Bot.GetGameEntity();
	while( this.State == this.STEALTH ) {
		sleep(0.5);
		this.GotoRandomAsync(32.0);
		while(!this.Bot.GetVelocity().IsZero()) {
			sleep(0.5);
			if (!GetEntFlags(botEnt, ENTFLAG.DISGUISED) ) {
				this.Finished();
			}
		}
	}
	this.Finished();
};

this.Exit = function()
{
	this.Priority = 0; // this func is called directly in some cases
	this.State = this.SPOT_MINES;
	this.TargetPosition = null;
	this.Bot.ReleaseButton(BTN.CROUCH, BTN.USE, BTN.ATTACK1);
	this.ReleaseAimRequest();
	this.ReleaseWeaponRequest();
};

this.UpdateDebugString = function()
{
	stateString = "";

	switch(this.State)
	{
		case this.GOTO_TARGET:
		{
			stateString = "GOTO_TARGET";
		}
		case this.GIB_TARGET:
		{
			stateString = "GIB_TARGET";
		}
		case this.STEAL_UNIFORM:
		{
			stateString = "STEAL_UNIFORM";
		}
		case this.SPOT_MINES:
		{
			stateString = "SPOT_MINES";
		}
		case this.STEALTH:
		{
			stateString = "STEALTH";
		}
		case this.SEARCH_FOR_CORPSE:
		{
			stateString = "SEARCH_FOR_CORPSE";
		}
		default:
		{
			stateString = "";
		}
	}

	// for /bot debugbot <bot or all> fpinfo prints
	this.DebugString = "state : " + stateString;
};

this.Events[EVENT.KILLEDSOMEONE] = function(victim, mod)
{
	if ( this.IsActive() || this.Bot.GetClass() != CLASS.COVERTOPS ) { return; }

	if ( victim ) {
		if ( this.Bot.GetTarget() == victim && this.Bot.DistanceTo(victim) < 1000 ) {
			// wait till it settles before getting a position
			timeout = 0; // just in case
			while ( victim && timeout < 90 && !GetEntVelocity(victim).IsZero() ) {
				yield();
				timeout += 1;
			}

			if ( this.Debug ) {
				this.Bot.Say("waited ", timeout, " frames for target to settle");
			}

			if ( timeout < 90 ) {
				this.TargetPosition = null;
				this.TargetEntity = victim;
				this.State = this.GOTO_TARGET;
				this.Priority = 1.0;
			}
		}
	}
};

this.Events[EVENT.FEEL_PAIN] = function(Inflictor, PreviousHealth, CurrentHealth)
{
	// interrupt any active state if taking fire (from targets that are alive ...)
	if ( Inflictor && !GetEntFlags(Inflictor, ENTFLAG.DEAD, ENTFLAG.LIMBO) ) {
		inflictorClass = GetEntClass(Inflictor);
		if ( (inflictorClass & CLASS.ANYPLAYER || inflictorClass == 1)
			&& GetEntTeam(Inflictor) != this.Bot.GetTeam() )
		{
			// just call Exit directly to handle states run in getpriority
			if ( this && this.IsActive() ) {
				this.Finished();
			}
			else if ( this && this.Exit ) {
				this.Exit();
			}
		}
	}
};
