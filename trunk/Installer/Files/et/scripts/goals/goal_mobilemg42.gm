this.Name = "MOBILEMG42";
this.Parent = "HighLevel";
this.SkipGetPriorityWhenActive = true;

this.LimitToWeapon( WEAPON.MOBILE_MG42 );

this.Initialize = function()
{
	this.Bot.QueryGoalsTable = table();
	this.FeelPainLocked = false; // throttle for the event

	this.SecondaryWeapons = table();
	this.SecondaryWeapons[WEAPON.COLT] = 1;
	this.SecondaryWeapons[WEAPON.LUGER] = 1;
	this.SecondaryWeapons[WEAPON.COLT_AKIMBO] = 1;
	this.SecondaryWeapons[WEAPON.LUGER_AKIMBO] = 1;
};

this.GetPriority = function()
{
	while(1)
	{
		if(Util.HasAmmoForWeapon(this.Bot, WEAPON.MOBILE_MG42))
		{
			count = this.QueryGoals(this.Bot.QueryGoalsTable,"MOBILEMG42_.*");
			if ( count > 0 )
			{
				foreach ( id and goal in this.Bot.QueryGoalsTable )
				{
					this.MapGoal = goal;
					this.Priority = goal.GetGoalPriority(this.Bot);
					break;
				}
			}

			tableClear(this.Bot.QueryGoalsTable);
		}

		sleep(2);
	}
};

this.Enter = function()
{
	// finish it once they run out of ammo
	this.AddFinishCriteria(this.Bot.GetGameEntity(),"not weaponhasammo", WEAPON.MOBILE_MG42_SET, 0);

	if(!this.MarkInProgress(this.MapGoal))
	{
		this.BlackboardDelay(5, this.MapGoal);
		this.Finished();
	}

	this.CampTime = RandFloat(this.MapGoal.MinCampTime, this.MapGoal.MaxCampTime);
};


this.Update = function()
{
	weapon = this.Bot.HasAnyWeapon(this.SecondaryWeapons);
	if (weapon)
	{
		this.AddWeaponRequest(Priority.Medium, weapon);
	}

	if ( this.RouteTo(this.MapGoal) == EVENT.PATH_SUCCESS )
	{
		// disable combat movement. note: if it is too late here,
		// there is no other choice but to move this to the Enter function
		if (!this.Bot.DisableCombatMovement)
		{
			this.CombatMovementDisabled = true;
			this.Bot.DisableCombatMovement = true;
		}

		if(!this.MarkInUse(this.MapGoal))
		{
			this.BlackboardDelay(5, this.MapGoal);
			this.Finished();
		}

		// note: they can only select one randomly each time they activate the goal
		// this is because there is no guarantee that they are able to cycle through each one
		// given the limits of the weapon while it is set.
		r = Util.GetRandomFromTable( this.MapGoal.AimVectors );
		this.AimVector = this.MapGoal.AimVectors[ r ];
		this.AddAimRequest(Priority.High, "facing", this.AimVector);

		this.AddWeaponRequest(Priority.High, WEAPON.MOBILE_MG42_SET );
		this.BlockForWeaponChange( WEAPON.MOBILE_MG42_SET );

		// wait while mounting mg42, it is necessary for correct aim vector
		sleep(2);

		this.Bot.HoldButton(BTN.PRONE, 999);

		// replace the aim request with a low priority one so the targeting system can take over
		this.AddAimRequest(Priority.Low, "facing", this.AimVector);

		timeout = 0;
		while( timeout < this.CampTime )
		{
			timeout += 1;
			sleep(1);
		}
	}
	else
	{
		this.BlackboardDelay(10, this.MapGoal);
		Util.MapDebugPrint( this.MapGoal.GetName() + " path failed, check reachability!", true );
	}

	this.BlackboardDelay(5, this.MapGoal);
	this.Finished();
};

this.IsOutOfRange = function(ent)
{
	if (!this.AimVector)
	{
		return true;
	}

	entPos = GetEntPosition(ent);
	botPos = this.Bot.GetPosition();

	if ( !entPos || !botPos )
	{
		return true;
	}

	v1 = (entPos - botPos).Normalize();
	v2 = this.AimVector.Normalize();
	return v1.DotProduct(v2) < 0.65;
};

this.Events[EVENT.FEEL_PAIN] = function(ent)
{
	// ignore non-player ents
	if (!ent || this.FeelPainLocked || GetGameIdFromEntity(ent) > 63)
	{
		return;
	}

	if (!this.Bot.IsAllied(ent) && this.IsOutOfRange(ent))
	{
		this.Bot.HoldButton(BTN.JUMP, 2);
		this.BlackboardDelay(7, this.MapGoal);
		this.Finished();
	}

	// throttle it since this event can be fired in rapid succession
	// we'll lose some precision, but this isn't critical functionality
	this.FeelPainLocked = true;
	sleep(1);
	this.FeelPainLocked = false;
};

this.Exit = function()
{
	if (this.CombatMovementDisabled) {
		this.Bot.DisableCombatMovement = false;
	}
	this.Bot.ReleaseButton(BTN.PRONE);
	this.ReleaseWeaponRequest();

	this.FeelPainLocked = false;
};

