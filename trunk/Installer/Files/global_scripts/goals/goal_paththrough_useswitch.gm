// This script contains functionality to trigger any available switches as set up in the global map table.

// This goal uses the global blackboard, so let's register a key for it.
if(!BB.PTSWITCHUSER)
{
	BB.PTSWITCHUSER = Blackboard.MakeKey();
}

// These parameters are required
this.Name = "UseSwitch_PT";		// The name of the goal.
this.Parent = "LowLevel";		// PathThrough states must be low level or they will not be used.

this.OnPathThrough = function(data)
{
	if (this.IsActive())
		{ return; }

	currentswitch = Map.Switches[data];
	if(currentswitch)
	{
		this.CurrentSwitch = data;
		this.counter = 0;

		if(currentswitch.Enabled)
		{
			return true; // script will activate
		}
	}
	else
	{
		print("OnPathThrough no switch", data);
	}

	this.CurrentSwitch = null;
	return false;  // script will not activate
};

this.Enter = function()
{
	currentswitch = Map.Switches[this.CurrentSwitch];

	bbRecord =
	{
		Owner = this.Bot.GetGameId(),
		Target = currentswitch.Serial,
	};
	Blackboard.PostRecord(BB.PTSWITCHUSER, bbRecord);
};

this.Exit = function()
{
	// Remove myself from the blackboard for using this switch
	Blackboard.RemoveByPoster(this.Bot.GetGameId(), BB.PTSWITCHUSER);
};

this.Update = function()
{
	currentswitch = Map.Switches[this.CurrentSwitch];

        if( !currentswitch.Timeout )
        {
                currentswitch.Timeout = 2000;
        }

	if( this.Goto(currentswitch.Waypoint.position, currentswitch.Waypoint.radius) == EVENT.PATH_SUCCESS )
	{
		currentswitch = Map.Switches[this.CurrentSwitch];

                if ( !currentswitch.AimPosition )
                {
                        this.AddAimRequest(Priority.High, "facing", currentswitch.Waypoint.facing);
                }
                else
                {
                        this.AddAimRequest(Priority.High, "position", currentswitch.AimPosition);
                }

		exitCondition = false;
		while( !exitCondition && currentswitch.Enabled && this.counter < currentswitch.Timeout )
		{
			this.counter += 250;
			this.Bot.MoveTowards(currentswitch.Waypoint.position);
			this.Bot.PressButton( BTN.USE);

			if ( currentswitch.ExitConditions )
			{
				foreach ( id and func in currentswitch.ExitConditions )
				{
					if ( func(this.Bot) == true )
					{
						if ( currentswitch.Debug )
							{ print(this.Bot.Name, "^2exit condition met for", currentswitch.WaypointName); }

						exitCondition = true;
						break;
					}
				}
			}

			sleep(0.25);
		}

		this.ReleaseAimRequest();
		if ( !exitCondition && currentswitch.Wait && this.counter < currentswitch.Timeout)
		{
			while ( currentswitch.Wait() != true )
			{
				this.Goto(this.Bot.GetPosition());
				yield();
			}
		}
	}
	else
	{
		this.BlackboardDelay(30, currentswitch.Serial);
	}

    // Finish the state.
	this.Finished();
};
